## 领哥卓越

1. 什么是可重入锁，什么样的结构可以保证可重入锁？
   - AQS
2. 缓存一致性方案   [参考文献](https://blog.csdn.net/qq_39408435/article/details/119846429)
   - 依赖redis的过期机制，定时刷新-----脏数据
   - 先更新数据库，再删除缓存 ----- 会有脏数组
   - 先删缓存，再更新数据库----- 会有脏数据
   - 延迟双删：删除缓存、更新数据库、删除缓存 ----- 主从复制情况查询从库会产生脏数据
   - 消息中间件：把删除缓存的消息加入到队列中，如果消息投递失败，就再次加入到队列执行，直到成功为止。我们就能够有效保证数据库和缓存数据不一致了，不管是读写分离还是其他情况，只要消息队列能够保证安全，那么缓存就一定会被刷新。（在发生删除消息前，Master需要等Slave节点发生ACK，否则在消息消费了，单主从并未完成同步，还是去从库读取旧值，可以参考下MySQL半同步复制）。
   - 通过订阅binlog来更新redis，把我们搭建的消费服务，作为mysql的一个slave，订阅binlog，解析出更新内容，再更新到redis。
3. 监听binlog的技术
   - **Canal**：伪装自己是slave，向MySQL master发送dump协议，MySQL master收到dump请求，开始推送binary log给slave（也就是canal）
4. 监听数据库的数据变化
   - my.ini中配置`log=mylog.log `
   - `Cannal`：监听binlog
5. 如何保障消息被正确消费
   - 消息顺序性：需要保持一致性的消息，投递到同一个队列中，失败后重试。https://www.sohu.com/a/129521820_487514
   - 消息一定被消费：服务端ACK + 客户端ACK。
   - 消息去重：客户端幂等性保证，消费消息表。
6. Mysql各种事务级别的实现方式
   - 序列化：表锁
   - 可重复读、读已提交：MVCC



## 商汤

1. mysql 锁定一行的时候，能读到数据么？
2. mysql锁膨胀过程
3. mysql各种锁
4. RocketMQ如果Broker挂了怎么办？   https://blog.csdn.net/a646705816/article/details/111461528
5. Synchronized 和 CAS 区别
6. 锁升级过程
7. ES为什么效率高，查询快
8. Mybatis怎么映射SQL的，源代码，多个相同id的怎么区分？



## Momenta

1. AOP底层处怎么实现的，源代码
2. Netty为什么高性能
   - 采用异步非阻塞的I/O类库，基于Reactor 模式实现，解决了传统同步阻塞I/O模式下一个服务端无法平滑地处理线性增长的客户端的问题。
   - TCP接收和发送缓冲区使用直接内存代替堆内存，避免了内存复制，提升了I/O读取和写入的性能。
   - 支持通过内存池的方式循环利用ByteBuf,避免了频繁创建和销毁ByteBuf带来
     的性能损耗。
   - 可配置的I/O线程数、TCP参数等，为不同的用户场景提供定制化的调优参数，满足不同的性能场景。
   - 采用环形数组缓冲区实现无锁化并发编程，代替传统的线程安全容器或者锁。
   - 合理地使用线程安全容器、原子类等，提升系统的并发处理能力。
   - 关键资源的处理使用单线程串行化的方式，避免多线程并发访问带来的锁竞争和额外的CPU资源消耗问题。
   - 通过引用计数器及时地申请释放不再被引用的对象，细粒度的内存管理降低了GC的频率，减少了频繁GC带来的时延增大和CPU损耗。
3. Spring，SpringBoot好处
4. 项目过程
5. 项目问题
   - OOM排查：
     - 对RocketMQ 的消费部门做了封装，为了实现链路追踪，我们把traceId存储到了threadlocal
     - 在消费结束的时候，调用threadlocal.remove()对存储的数据进行了移除
     - 然而，在Rocket底层使用的Netty中，在ObjectCleaner中存储了一个LIVE_SET，里面存储的是AutomaticCleanerReference（弱引用）的Set集合，消费线程会把FastThreadLocal保存起来，等消费线程结束之后，进行清除这些FastThreadLocal，然而由于ThreadLocal被清理掉，导致threadLocalMap.isCleanerFlagSet(index)为false。从而导致Netty里面的ThreadLocal不能被回收
     - 解决：定义自己的ThrealLocal类型，清除的时候，进行判断
6. 通过业务主动注册接口来完成有什么不好？如果这个时间调用不同，就查不到相应的数据，如果使用MQ解耦，可以看到旧数据



## 中电集成

1. Netty组件
   - Channel：传入或者传出的数据载体，可以被打开或者关闭，连接或者断开连接
   - EventLoop：用于处理IO事件，多线程模型、并发
   - ChannelHandler、ChannelPipeline：负责处理接受和发送数据的业务逻辑
   - ByteBuf：内存单元
   - 核心三件套：Buffer、Selector、Channel
2. mybatis分页方式
   - 直接limit
   - 分页插件
3. #和 ￥ 区别
   - #可以防止SQL注入
   - $可以引用数据库对象，如数据库名、表名等
4. 用到的springcloud组件
   - Feign、Ribbon：服务调用、负载均衡
   - Hystrix：限流、雪崩、熔断
   - Nacos：服务注册
   - GateWay：网关
5. 消息的完整性保障
6. 消息消费模式
   - 集群模式
   - 广播模式
7. RocketMQ延时队列
   - 设置不同级别的消息延迟，如1s 2s ... 2h 等，让不同规格的消息存储到不同的队列（数据库表、redis中间件等）
   - 为每个级别延时消息配置一个定时器，每次扫描时间比这个早的消息，进行投递
8. RocketMQ的消息重发，是需要自己做，还是自己提供了相应机制
9. 服务哪里用了多线程
   - 数据清洗
10. 线程池种类
    - newCachedThreadPool创建一个可缓存线程池程
    - newFixedThreadPool 创建一个定长线程池
    - newScheduledThreadPool 创建一个周期性执行任务的线程池
    - newSingleThreadExecutor 创建一个单线程化的线程池



## OPAY  人数少，20人

1. 三次握手、四次挥手过程的TCP状态变化

2. Redis集群模式

3. ES 刷盘策略

4. ES落盘策略

5. ES集群架构

   主从架构，一个Index包含多个有分片（数据切分）和副本（备份防止丢失）

   - 节点类型
     - Master：主节点
       - `node.data ＝ true`
       - 索引创建和删除
       - 跟踪节点状态
       - 决定分片如何分配
     - Voting ：投票节点
       - `node.voting_only = true` 仅仅投票，也可以作为数据节点
     - Coordinating：协调节点
       - 如果同时设置了data.master = false和data.data=false，那么此节点将成为仅协调节点。
       - 处理路由和搜索请求，智能的负载均衡
     - Data：数据节点
       - 存储索引数据
       - 对文档进行增删改查，聚合操作

6. ES实时性     https://www.jianshu.com/p/cd608a5cc8f2

7. RocketMQ回溯

8. STW出现的环节

9. redis哨兵模式和集群模式各自有优缺点、spring怎么连接

   - 架构

     - 哨兵模式

        ![img](https://img2018.cnblogs.com/blog/1350922/201910/1350922-20191006122611921-809764078.png)

     - 集群模式

        ![img](https://img2018.cnblogs.com/blog/1350922/201910/1350922-20191006124637992-2055348918.png)

   - 连接方式

     - 单机模式
       - spring.redis.host   会自动生成RedisConnectionFactory，然后利用template.setConnectionFactory，生成RedisTemplate
     - 集群模式
       - spring.redis.cluster.nodes=ip1:port1,ip2:port2...        获取后自行切割解析成Set<HostAnPort> nodes
       - RedisClusterConfiguration.setClusterNodes(nodes)
       - 生成RedisTemplate
       - 请求过程为：
         - 从集群节点列表中随机选择一个节点
         - 从该节点获取一个客户端连接（如果配置了连接池，从连接池中获取），执行命令
         - 如果抛出ClusterRedirectException异常，则跳转到返回的目标节点上执行
         - 如果跳转次数大于配置的值 max-redirects， 则抛出TooManyClusterRedirectionsException异常
     - 哨兵模式
       - spring.redis.sentinel.master  和 spring.redis.sentinel.nodes 分别用来配置集群名和哨兵节点，
       - 内部会生成一个JedisSentinelPool，该类的初始化过程中，会对每一个Node尝试构建Jedis对象，通过jedis.sentinelGetMasterAddrByName方法来获取master节点信息
       - 对每一个哨兵节点通过一个 MasterListener 进行监听（Redis的发布订阅功能），订阅哨兵节点`+switch-master`频道，当发生故障转移时，客户端能收到哨兵的通知，通过重新初始化连接池，完成主节点的切换

   - 节点失败检测

     - 集群模式
       - 各个节点之间有互相的检测，如果超过半数的节点检测失效时，认为该节点失效
     - 哨兵模式
       - 一个哨兵发现节点离线，标识为主观下线，如果超过半数哨兵发现节点下线后，会发现主节点切换过程，完成之后，主节点会客观下线

   - 数据存储

     - 哨兵模式

       - 集群中每台redsi服务器的数据相同，浪费内存，数据同步采用主从赋值

     - 集群模式

       - 实现了redis的分布式存储，每天redis节点上存储不同的内容

       



## 其他

1. kafka和rocketmq选型
2. IO模型
3. 网络编程模型
   - BIO
   - NIO
   - AIO
4. BeanFactory 和 FactoryBean 的区别：https://zhuanlan.zhihu.com/p/196688174