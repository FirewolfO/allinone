## 领哥卓越

1. 什么是可重入锁，什么样的结构可以保证可重入锁？
   - RetrantLock 和 Synchronized都是可重入锁可以多次获取到锁的，每次获取锁，加锁的标记数加+1，解锁的时候-1，加锁和解锁是配对的
   - 采用AQS来实现锁
2. 缓存一致性方案   [参考文献](https://blog.csdn.net/qq_39408435/article/details/119846429)
   - 依赖redis的过期机制，定时刷新-----脏数据
   - 先更新数据库，再删除缓存 ----- 会有脏数组
   - 先删缓存，再更新数据库----- 会有脏数据
   - 延迟双删：删除缓存、更新数据库、删除缓存 ----- 主从复制情况查询从库会产生脏数据
   - 消息中间件：把删除缓存的消息加入到队列中，如果消息投递失败，就再次加入到队列执行，直到成功为止。我们就能够有效保证数据库和缓存数据不一致了，不管是读写分离还是其他情况，只要消息队列能够保证安全，那么缓存就一定会被刷新。（在发生删除消息前，Master需要等Slave节点发生ACK，否则在消息消费了，单主从并未完成同步，还是去从库读取旧值，可以参考下MySQL半同步复制）。
   - 通过订阅binlog来更新redis，把我们搭建的消费服务，作为mysql的一个slave，订阅binlog，解析出更新内容，再更新到redis。
3. 监听binlog的技术
   - **Canal**：伪装自己是slave，向MySQL master发送 dump协议，MySQL master收到dump请求，开始推送binary log给slave（也就是canal）
4. 监听数据库的数据变化
   - my.ini中配置`log=mylog.log `，监听日志变化
   - `Cannal`：监听binlog
5. 如何保障消息被正确消费
   - 消息顺序性：需要保持一致性的消息，投递到同一个队列中，失败后重试。https://www.sohu.com/a/129521820_487514
   - 消息一定被消费
     - 服务端：同步发送、失败重试、死信队列
     - 客户端：ACK、失败重试。
   - 消息去重：需要自己实现客户端幂等性保证，消费消息表、消息标识进行唯一约束
6. Mysql各种事务级别的实现方式
   - 序列化：表锁
   - 可重复读、读已提交：MVCC



## 商汤

1. mysql 写锁定一行的时候，其他别的能读到数据么？

   - 不可以，会阻塞其他请求。
2. InnoDB锁膨胀过程

   - 只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！
3. mysql各种锁

   - 行锁
   - 间隙锁
   - 临界锁
   - 页锁
   - 表锁
4. RocketMQ如果Broker挂了怎么办？   https://blog.csdn.net/a646705816/article/details/111461528
- 架构上需要采用master-slave架构，如果主节点挂了，slave上线
5. Synchronized 和 CAS 区别

   - CAS：乐观锁的一种实现方式，是一个轻量级锁，可能有ABA和循环过多开销过大的问题，JDK旧版本只能操作单个变量
   - Synchronized：悲观锁，必须先获取锁，然后再操作，通过monitorenter和monitorexit指令完成同步代码块的进入和离开
6. Synchronized加在静态方法和普通方法的区别

   - 静态方法锁的是当前类的Class对象
   - 普通方法锁的是当前实例对象
7. 锁升级过程

   - 偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
     - 偏向锁撤销：使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点。首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
   - 轻量级锁：创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
   - 重量级锁：因为自旋会消耗CPU，为了避免无用的自旋，升级为重量级锁
8. ES为什么效率高，查询快

   - 存储采用倒排索引
9. Mybatis怎么映射SQL的，源代码，多个相同id的怎么区分？

   - 区分：namespace + id 唯一区分

## Momenta

1. AOP底层处怎么实现的，源代码
2. Netty为什么高性能
   - 采用异步非阻塞的I/O类库，基于Reactor 模式实现，解决了传统同步阻塞I/O模式下一个服务端无法平滑地处理线性增长的客户端的问题。
   - TCP接收和发送缓冲区使用直接内存代替堆内存，避免了内存复制，提升了I/O读取和写入的性能。
   - 支持通过内存池的方式循环利用ByteBuf,避免了频繁创建和销毁ByteBuf带来
     的性能损耗。
   - 可配置的I/O线程数、TCP参数等，为不同的用户场景提供定制化的调优参数，满足不同的性能场景。
   - 采用环形数组缓冲区实现无锁化并发编程，代替传统的线程安全容器或者锁。
   - 合理地使用线程安全容器、原子类等，提升系统的并发处理能力。
   - 关键资源的处理使用单线程串行化的方式，避免多线程并发访问带来的锁竞争和额外的CPU资源消耗问题。
   - 通过引用计数器及时地申请释放不再被引用的对象，细粒度的内存管理降低了GC的频率，减少了频繁GC带来的时延增大和CPU损耗。
3. Spring，SpringBoot好处
4. 项目过程
5. 项目问题
   - OOM排查：
     - 对RocketMQ 的消费部门做了封装，为了实现链路追踪，我们把traceId存储到了threadlocal
     - 在消费结束的时候，调用threadlocal.remove()对存储的数据进行了移除
     - 然而，在Rocket底层使用的Netty中，在ObjectCleaner中存储了一个LIVE_SET，里面存储的是AutomaticCleanerReference（弱引用）的Set集合，消费线程会把FastThreadLocal保存起来，等消费线程结束之后，进行清除这些FastThreadLocal，然而由于ThreadLocal被清理掉，导致threadLocalMap.isCleanerFlagSet(index)为false。从而导致Netty里面的ThreadLocal不能被回收
     - 解决：定义自己的ThrealLocal类型，清除的时候，进行判断
6. 通过业务主动注册接口来完成数据看板，可以么？
   - 也可以，缺点：如果这个时间调用不同，就查不到相应的数据，如果使用MQ解耦，可以看到旧数据



## 中电集成

1. Netty组件
   - Channel：传入或者传出的数据载体，可以被打开或者关闭，连接或者断开连接
   - EventLoop：用于处理IO事件，多线程模型、并发
   - ChannelHandler、ChannelPipeline：负责处理接受和发送数据的业务逻辑
   - ByteBuf：内存单元
   - 核心三件套：Buffer、Selector、Channel
   
2. mybatis分页方式
   - 直接limit
   - 分页插件
   
3. #和 ￥ 区别
   - #可以防止SQL注入
   - $可以引用数据库对象，如数据库名、表名等
   
4. 用到的springcloud组件
   - Feign、Ribbon：服务调用、负载均衡
   - Hystrix：限流、雪崩、熔断
   - Nacos：服务注册
   - GateWay：网关
   
5. 消息的完整性保障

6. 消息消费模式
   - 集群模式
   - 广播模式
   
7. RocketMQ延时队列

   - 提供能量
     - 提供18个等级的延时队列  1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h
     - 通过`RocketMQProducer.sendDelay("messageKey","message消息体",延时级别);` 发送延时消息
   - 实现原理
     - 设置不同级别的消息延迟，如1s 2s ... 2h 等，让不同规格的消息存储到不同的队列（数据库表、redis中间件等）
     - 为每个级别延时消息配置一个定时器，每次扫描时间比这个早的消息，进行投递

8. RocketMQ的消息重试

   - producer重试

     可以配置超时时间、重试次数、是否发送到下一个broker

     ```csharp
     rocketmq:
       name-server: http://101.200.36.168:9876
       producer:
         #指定消息发送者的组，在控制台查询时会用到
         group: test
         #发送失败超时时间
         send-message-timeout: 3000
         #重试次数
         retry-times-when-send-failed: 3
         #在其他broker服务端进行重试默认false，开启设置为on
         retry-next-server: false
     ```

   - consumer重试

     - 可以通过抛出异常的方式或者回执失败的来完成重试
     - 重试机制和延时等级一致
     - 可以通过` consumer.setMaxReconsumeTimes(2)`设置最大重试次数

9. 服务哪里用了多线程

   - 数据清洗

10. 线程池

    - 种类
      - newCachedThreadPool创建一个可缓存线程池程
      - newFixedThreadPool 创建一个定长线程池
      - newScheduledThreadPool 创建一个周期性执行任务的线程池
      - newSingleThreadExecutor 创建一个单线程化的线程池
    - 核心参数
      - corePoolSize：核心线程数
      - maxPoolSize：最大线程数
      - keepAlivetime：线程空闲时间
      - unit：线程等待时间单位
      - rejectedExecutionHandler：任务拒绝处理器
        - AbortPolicy ：丢弃任务，抛出异常
        - CallerRunsPolicy：执行任务
        - DiscardPolicy：忽略
        - DiscardOldestPolicy：从队列中踢出最先进入队列
      - threadFactory：线程工厂
      - blockingQueue：阻塞队列
    - 线程个数设置 
      - 最佳线程数 = Ncpu * Ucpu * (1 + W/C)
        - Ncpu：CPU核数，如 12
        - Ucpu：CPU利用率，如0.9
        - W/C：等待时间/计算时间，如：50（sleep时间） / 50 (循环50_000_000耗时)   = 1

## OPAY

1. 三次握手、四次挥手过程的TCP状态变化

3. ES 刷盘策略

4. ES落盘策略

5. ES集群架构

   主从架构，一个Index包含多个有分片（数据切分）和副本（备份防止丢失）

   - 节点类型
     - Master：主节点
       - `node.data ＝ true`
       - 索引创建和删除
       - 跟踪节点状态
       - 决定分片如何分配
     - Voting ：投票节点
       - `node.voting_only = true` 仅仅投票，也可以作为数据节点
     - Coordinating：协调节点
       - 如果同时设置了data.master = false和data.data=false，那么此节点将成为仅协调节点。
       - 处理路由和搜索请求，智能的负载均衡
     - Data：数据节点
       - 存储索引数据
       - 对文档进行增删改查，聚合操作

5. ES实时性     https://www.jianshu.com/p/cd608a5cc8f2

   - 倒排索引结构

6. TOP命令

7. RocketMQ回溯

   - 支持按照毫米的精确度来回溯

8. STW出现的环节

9. redis哨兵模式和集群模式各自有优缺点、spring怎么连接

   - 架构

     - 哨兵模式

        ![img](https://img2018.cnblogs.com/blog/1350922/201910/1350922-20191006122611921-809764078.png)

     - 集群模式

        ![img](https://img2018.cnblogs.com/blog/1350922/201910/1350922-20191006124637992-2055348918.png)

   - 连接方式

     - 单机模式
       - spring.redis.host   会自动生成RedisConnectionFactory，然后利用template.setConnectionFactory，生成RedisTemplate
     - 集群模式
       - spring.redis.cluster.nodes=ip1:port1,ip2:port2...        获取后自行切割解析成Set<HostAnPort> nodes
       - RedisClusterConfiguration.setClusterNodes(nodes)
       - 生成RedisTemplate
       - 请求过程为：
         - 从集群节点列表中随机选择一个节点
         - 从该节点获取一个客户端连接（如果配置了连接池，从连接池中获取），执行命令
         - 如果抛出ClusterRedirectException异常，则跳转到返回的目标节点上执行
         - 如果跳转次数大于配置的值 max-redirects， 则抛出TooManyClusterRedirectionsException异常
     - 哨兵模式
       - spring.redis.sentinel.master  和 spring.redis.sentinel.nodes 分别用来配置集群名和哨兵节点，
       - 内部会生成一个JedisSentinelPool，该类的初始化过程中，会对每一个Node尝试构建Jedis对象，通过jedis.sentinelGetMasterAddrByName方法来获取master节点信息
       - 对每一个哨兵节点通过一个 MasterListener 进行监听（Redis的发布订阅功能），订阅哨兵节点`+switch-master`频道，当发生故障转移时，客户端能收到哨兵的通知，通过重新初始化连接池，完成主节点的切换

   - 节点失败检测

     - 集群模式
       - 各个节点之间有互相的检测，如果超过半数的节点检测失效时，认为该节点失效
     - 哨兵模式
       - 一个哨兵发现节点离线，标识为主观下线，如果超过半数哨兵发现节点下线后，会发现主节点切换过程，完成之后，主节点会客观下线

   - 数据存储

     - 哨兵模式

       - 集群中每台redsi服务器的数据相同，浪费内存，数据同步采用主从赋值

     - 集群模式

       - 实现了redis的分布式存储，每天redis节点上存储不同的内容




## 广联达

1. Filter 、拦截器区别，哪里用了过滤器，哪里用了拦截器

   - filter接口在javax.servlet包下面，是servlet规定的。inteceptor定义在org.springframework.web.servlet中，可以用于web程序，也可以用于普通的应用；
   - filter是servlet容器支持的，interceptor是spring框架支持的
   - filter通过dochain放行，interceptor通过prehandler放行。
   - filter只在方法前后执行，interceptor粒度更细，可以深入到方法前后，异常抛出前后
   - 拦截器是基于Java反射的，

   > 执行顺序：Filter > Listener > Interceptor

2. Zuul 和 gateway 区别

3. 项目业务架构

4. SpringBoot自动装配原理

5. 自定义过starter么？用来做什么？怎么自定义的

   - META-INF下面创建spring.factories文件，里面配置 autoConfiguration= 自动配置类
   - 在自己的自动配置类里面，装配自己的bean，通过一些@ConditionalOnXXX的形式来进行条件装配

6. AOP底层原理

   https://www.cnblogs.com/zedosu/p/6709921.html

7. 哪里用了Redis？

   - 基础信息的存储：人员、设备、时间计划、区域等
   - 分布式锁Redission，缓存过期时间，30s ~ 1d 不等

8. Redis CPU 消耗比较高可能原因

   - 客户的业务负载过重，qps过高，导致CPU被用满，排查方法请参考[排查QPS是否过高](https://support.huaweicloud.com/trouble-dcs/dcs-trouble-0715002.html#dcs-trouble-0715002__section8519162751218)。
   - 使用了keys等消耗资源的命令，排查及处理措施请参考[查找并禁用高消耗命令](https://support.huaweicloud.com/trouble-dcs/dcs-trouble-0715002.html#dcs-trouble-0715002__section6300145853215)。
   - 发生Redis的持久化重写操作，排查及处理措施请参考[是否存在Redis的持久化重写操作](https://support.huaweicloud.com/trouble-dcs/dcs-trouble-0715002.html#dcs-trouble-0715002__section6314242121514)。

9. RocketMQ架构

   ![image-20220326092333452](https://gitee.com/firewolf/allinone/raw/master/images/image-20220326092333452.png)

   - 工作过程
     - 各 NameServer 之间无任何数据交互，Broker 启动之后会向所有 NameServer 定期（每 30s）发送心跳包，包括：IP、Port、TopicInfo，NameServer 会定期扫描 Broker 存活列表，如果超过 120s 没有心跳则移除此 Broker 相关信息，代表下线
     - 每个 NameServer 就知道集群所有 Broker 的相关信息，此时 Producer 上线从 NameServer 就可以得知它要发送的某 Topic 消息在哪个 Broker 上，和对应的 Broker （Master 角色的）建立长连接，发送消息
     - Consumer 上线也可以从 NameServer 得知它所要接收的 Topic 是哪个 Broker ，和对应的 Master、Slave 建立连接，接收消息。
   - 推、拉消息的区别
   - 架构

10. RocketMQ的事务消息使用过么？

11. 分布式锁加锁解锁过程、到时间了没有执行完怎么办？  （https://blog.csdn.net/asd051377305/article/details/108384490）

    - 基于Redis命令
      - 加锁：执行setNX，如果成功，执行expire添加过期时间
      - 解锁：执行delete命令
      - 缺点：expire执行失败，就可能出现死锁；不支持阻塞等待，不支持重入
    - RedissionLock
      - Redisson 支持单点模式、主从模式、哨兵模式、集群模式
      - 加锁解锁过程都使用lua脚本进行交互，保证了原子性
      - 唯一标识：获取锁时set的唯一值，实现上为redisson客户端**ID(UUID)+线程ID**
      - 加锁：通过exists判断是否存在，存在则通过hset设置为1，然后执行pexpire设置过期时间；通过hexists判断锁存在并且唯一标识存在，如果锁存在，表明是重入，则通过hincrby给锁重入计数加1，并设置过期时间；如果所存在，则执行pttl命令返回锁的过期时间
      - 解锁：通过exists判断如果锁不存在，则通过publish发布消息；通过hexists判断如果所存在但是唯一标识不是当前线程，则不允许解锁；如果锁存在并且和当前唯一标识匹配，则通过hincrby给重入计数-1；如果计数仍大于0，则通过pexpire重设过期时间，否则通过del删除锁，然后通过publish发布消息。
      - 解锁过程中的广播，是为了统治阻塞线程去抢锁；
      - **RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题**
    - RedissionRedLock
      - 需要额外为RedissionRedLock 搭建Redis环境
      - 加锁：依次尝试从多个redis实例节点上获取锁（需要设置获取超时时间），只有超过半数节点上面获取锁成功（在超时时间内获取到锁）才算成功；如果获取锁失败，则在所有的redis实例上进行解锁操作；
      - 其他的和RedissionLock一致
    - lua脚本
      - lua脚本在执行的时候具有排他性，不允许其他命令或者脚本执行，类似于通过 MULTI/EXEC 指令保障一批操作具有原子性。但是由于redis事务不会回滚，所以一定要保证lua脚本的正确性
      - 使用上:`eval "if redis.call('get', KEYS[1]) == false then redis.call('set', KEYS[1], ARGV[1])`
        - eval：redis执行lua脚本
        - call/pcall：返回的错误不同
    - 怎么做到一定能解锁？
      - 通常会通过过期时间保障一定能解锁；
    - 怎么样保证过期时间一定设置成功？ 
      - 通过 `SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]` 这个原子命令实现。  
        - EX：设置超时时间，单位秒
        - PX：设置超时时间，单位毫秒
        - NX：当key不存在才进行设置
        - XX：当key存在的时候设置
      - 通过lua脚本完成

    - 时间到了，没有执行完怎么办？
      - 采用缓存续命（watchdo(看门狗)）组件）：一个后台线程每隔10秒（需要小于锁的过期时间，通常是过期时间的1/3）检查是否还持有锁（Redission实例还存在），如果持有则延长锁的时间为过期时间。

12. Redis的事务

    - 不保障原子性，某个命令是错误的，则整体失败；正确的命令执行失败，则不会影响其他命令

13. 你认为你做架构师的话，需要有哪些改进

    - 系统架构、技术架构、具体的技术问题、技术攻关、资源分配


## 其他

1. kafka和rocketmq选型
   - 吞吐量上：kafka单机几十、几百万tps; RocketMQ单机7万左右
2. IO模型
3. 网络编程模型
   - BIO
   - NIO
   - AIO
4. BeanFactory 和 FactoryBean 的区别：https://zhuanlan.zhihu.com/p/196688174



事务消息

广播模式、集群模式的

hashMap get 时间复杂度