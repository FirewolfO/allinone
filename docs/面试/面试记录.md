## 领哥卓越

1. 什么是可重入锁，什么样的结构可以保证可重入锁？
   - AQS
2. 缓存一致性方案   [参考文献](https://blog.csdn.net/qq_39408435/article/details/119846429)
   - 依赖redis的过期机制，定时刷新-----脏数据
   - 先更新数据库，再删除缓存 ----- 会有脏数组
   - 先删缓存，再更新数据库----- 会有脏数据
   - 延迟双删：删除缓存、更新数据库、删除缓存 ----- 主从复制情况查询从库会产生脏数据
   - 消息中间件：把删除缓存的消息加入到队列中，如果消息投递失败，就再次加入到队列执行，直到成功为止。我们就能够有效保证数据库和缓存数据不一致了，不管是读写分离还是其他情况，只要消息队列能够保证安全，那么缓存就一定会被刷新。（在发生删除消息前，Master需要等Slave节点发生ACK，否则在消息消费了，单主从并未完成同步，还是去从库读取旧值，可以参考下MySQL半同步复制）。
   - 通过订阅binlog来更新redis，把我们搭建的消费服务，作为mysql的一个slave，订阅binlog，解析出更新内容，再更新到redis。
3. 监听binlog的技术
   - **Canal**：伪装自己是slave，向MySQL master发送dump协议，MySQL master收到dump请求，开始推送binary log给slave（也就是canal）
4. 监听数据库的数据变化
   - my.ini中配置`log=mylog.log `
   - `Cannal`：监听binlog
5. 如何保障消息被正确消费
   - 消息顺序性：需要保持一致性的消息，投递到同一个队列中，失败后重试。https://www.sohu.com/a/129521820_487514
   - 消息一定被消费：服务端ACK + 客户端ACK。
   - 消息去重：客户端幂等性保证，消费消息表。
6. Mysql各种事务级别的实现方式
   - 序列化：表锁
   - 可重复读、读已提交：MVCC



## 商汤

1. mysql 锁定一行的时候，能读到数据么？
2. mysql锁膨胀过程
3. mysql各种锁
4. RocketMQ如果Broker挂了怎么办？   https://blog.csdn.net/a646705816/article/details/111461528
5. Synchronized 和 CAS 区别
6. 锁升级过程
7. ES为什么效率高，查询快
8. Mybatis怎么映射SQL的，源代码，多个相同id的怎么区分？



## Momenta

1. AOP底层处怎么实现的，源代码
2. Netty为什么高性能
   - 采用异步非阻塞的I/O类库，基于Reactor 模式实现，解决了传统同步阻塞I/O模式下一个服务端无法平滑地处理线性增长的客户端的问题。
   - TCP接收和发送缓冲区使用直接内存代替堆内存，避免了内存复制，提升了I/O读取和写入的性能。
   - 支持通过内存池的方式循环利用ByteBuf,避免了频繁创建和销毁ByteBuf带来
     的性能损耗。
   - 可配置的I/O线程数、TCP参数等，为不同的用户场景提供定制化的调优参数，满足不同的性能场景。
   - 采用环形数组缓冲区实现无锁化并发编程，代替传统的线程安全容器或者锁。
   - 合理地使用线程安全容器、原子类等，提升系统的并发处理能力。
   - 关键资源的处理使用单线程串行化的方式，避免多线程并发访问带来的锁竞争和额外的CPU资源消耗问题。
   - 通过引用计数器及时地申请释放不再被引用的对象，细粒度的内存管理降低了GC的频率，减少了频繁GC带来的时延增大和CPU损耗。
3. Spring，SpringBoot好处
4. 项目过程
5. 项目问题
   - OOM排查：
     - 对RocketMQ 的消费部门做了封装，为了实现链路追踪，我们把traceId存储到了threadlocal
     - 在消费结束的时候，调用threadlocal.remove()对存储的数据进行了移除
     - 然而，在Rocket底层使用的Netty中，在ObjectCleaner中存储了一个LIVE_SET，里面存储的是AutomaticCleanerReference（弱引用）的Set集合，消费线程会把FastThreadLocal保存起来，等消费线程结束之后，进行清除这些FastThreadLocal，然而由于ThreadLocal被清理掉，导致threadLocalMap.isCleanerFlagSet(index)为false。从而导致Netty里面的ThreadLocal不能被回收
     - 解决：定义自己的ThrealLocal类型，清除的时候，进行判断
6. 通过业务主动注册接口来完成有什么不好？如果这个时间调用不同，就查不到相应的数据，如果使用MQ解耦，可以看到旧数据



## 中电集成

1. Netty组件
   - Channel：传入或者传出的数据载体，可以被打开或者关闭，连接或者断开连接
   - EventLoop：用于处理IO事件，多线程模型、并发
   - ChannelHandler、ChannelPipeline：负责处理接受和发送数据的业务逻辑
   - ByteBuf：内存单元
   - 核心三件套：Buffer、Selector、Channel
2. mybatis分页方式
   - 直接limit
   - 分页插件
3. #和 ￥ 区别
   - #可以防止SQL注入
   - $可以引用数据库对象，如数据库名、表名等
4. 用到的springcloud组件
   - Feign、Ribbon：服务调用、负载均衡
   - Hystrix：限流、雪崩、熔断
   - Nacos：服务注册
   - GateWay：网关
5. 消息的完整性保障
6. 消息消费模式
   - 集群模式
   - 广播模式
7. RocketMQ延时队列
   - 设置不同级别的消息延迟，如1s 2s ... 2h 等，让不同规格的消息存储到不同的队列（数据库表、redis中间件等）
   - 为每个级别延时消息配置一个定时器，每次扫描时间比这个早的消息，进行投递
8. RocketMQ的消息重发，是需要自己做，还是自己提供了相应机制
9. 服务哪里用了多线程
   - 数据清洗
10. 线程池种类
    - newCachedThreadPool创建一个可缓存线程池程
    - newFixedThreadPool 创建一个定长线程池
    - newScheduledThreadPool 创建一个周期性执行任务的线程池
    - newSingleThreadExecutor 创建一个单线程化的线程池



## OPAY  人数少，20人

1. 三次握手、四次挥手过程的TCP状态变化
2. Redis集群模式
3. ES 刷盘策略
4. ES落盘策略
5. ES实时性     https://www.jianshu.com/p/cd608a5cc8f2
6. RocketMQ回溯
7. STW出现的环节
8. redis哨兵模式和集群模式各自有优缺点、spring怎么连接
9. Spring怎么判断是在操作主节点还是从节点



## 其他

1. kafka和rocketmq选型
2. IO模型
3. 网络编程模型
   - BIO
   - NIO
   - AIO
4. BeanFactory 和 FactoryBean 的区别：https://zhuanlan.zhihu.com/p/196688174