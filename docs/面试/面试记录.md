## 领哥卓越

1. 什么样的结构可以保证可重入锁？
   - AQS
2. 缓存一致性方案   [参考文献](https://blog.csdn.net/qq_39408435/article/details/119846429)
   - 依赖redis的过期机制，定时刷新-----脏数据
   - 先更新数据库，再删除缓存 ----- 会有脏数组
   - 先删缓存，再更新数据库----- 会有脏数据
   - 延迟双删：删除缓存、更新数据库、删除缓存 ----- 主从复制情况查询从库会产生脏数据
   - 消息中间件：把删除缓存的消息加入到队列中，如果消息投递失败，就再次加入到队列执行，直到成功为止。我们就能够有效保证数据库和缓存数据不一致了，不管是读写分离还是其他情况，只要消息队列能够保证安全，那么缓存就一定会被刷新。（在发生删除消息前，Master需要等Slave节点发生ACK，否则在消息消费了，单主从并未完成同步，还是去从库读取旧值，可以参考下MySQL半同步复制）。
   - 通过订阅binlog来更新redis，把我们搭建的消费服务，作为mysql的一个slave，订阅binlog，解析出更新内容，再更新到redis。
3. 监听binlog的技术
   - **Canal**：伪装自己是slave，向MySQL master发送dump协议，MySQL master收到dump请求，开始推送binary log给slave（也就是canal）
4. 监听数据库的数据变化
   - my.ini中配置`log=mylog.log `
   - `Cannal`：监听binlog
5. 如何保障消息被正确消费
   - 消息顺序性：需要保持一致性的消息，投递到同一个队列中，失败后重试。https://www.sohu.com/a/129521820_487514
   - 消息一定被消费：服务端ACK + 客户端ACK。
   - 消息去重：客户端幂等性保证，消费消息表。