[toc]

# 缓存击穿、缓存雪崩、缓存穿透

## 缓存击穿

某一个热点数据在缓存中不存在了（如过期删除了），此时大量访问这个热点数据的请求打过来，会请求到DB

### 解决方案

- 缓存设置不过期：会有数据不一致的问题
- 使用锁来避免对一个没有缓存的数据进行大量的访问（多个请求）



## 缓存雪崩

- 某个时间点太多缓存key过期，因为缓存服务挂掉或者热点缓存失效，所有请求都去查数据库，导致数据库连接不够或者数据库处理不过来，从而导致整个系统不可用
- 缓存还没有加载就收到大量请求，如服务刚刚启动

### 解决方案

- 交错失效时间
- 线程互斥：让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据才可以，每个时刻只有一个线程在执行请求，减轻了db的压力，但缺点也很明显，降低了系统的qps。



## 缓存穿透

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大

### 解决方案

- 在服务器端，接收参数时业务接口中过滤不合法的值，null，负值，和空值进行检测和空值
- 使用bloomFilter
- .空值缓存：一种比较简单的解决办法，在第一次查询完不存在的数据后，将该key与对应的空值也放入缓存中，只不过设定为较短的失效时间，例如几分钟，这样则可以应对短时间的大量的该key攻击，设置为较短的失效时间是因为该值可能业务无关，存在意义不大，且该次的查询也未必是攻击者发起，无过久存储的必要，故可以早点失效。



# 布隆过滤器（BloomFilter）

## 应用场景

- 缓存穿透解决：使用布隆过滤器，将全部的有效数据都走一遍布隆过滤器，这样新来请求时，先走一遍请求的元素是否能通过布隆过滤器的验证，若未通过就直接放弃请求，若通过再执行查询（比在redis中缓存空值要节省空间）
- 推荐去重：有一定误判

## 实现原理

Bloom Filter是一种空间效率很高的随机数&spm=1001.2101.3001.7020)据结构，Bloom filter 可以看做是对bit-map 的扩展，布隆过滤器被设计为一个具有N的元素的位数组A（bit array），初始时所有的位都置为0。

当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了。

- 如果这些点有任何一个 0，则被检索元素一定不在；
- 如果都是 1，则被检索元素很可能在。



# 缓存一致性方案

  [参考文献](https://blog.csdn.net/qq_39408435/article/details/119846429)

- 依赖redis的过期机制，定时刷新-----脏数据
- 先更新数据库，再删除缓存 ----- 会有脏数据
- 先删缓存，再更新数据库----- 会有脏数据
- 延迟双删：删除缓存、更新数据库、删除缓存 ----- 主从复制情况查询从库会产生脏数据
- 消息中间件：把删除缓存的消息加入到队列中，如果消息投递失败，就再次加入到队列执行，直到成功为止。我们就能够有效保证数据库和缓存数据不一致了，不管是读写分离还是其他情况，只要消息队列能够保证安全，那么缓存就一定会被刷新。（在发生删除消息前，Master需要等Slave节点发生ACK，否则在消息消费了，单主从并未完成同步，还是去从库读取旧值，可以参考下MySQL半同步复制）。
- 通过订阅binlog来更新redis，把我们搭建的消费服务，作为mysql的一个slave，订阅binlog，解析出更新内容，再更新到redis。
  - 监听binlog的技术
    - **Canal**：伪装自己是slave，向MySQL master发送 dump协议，MySQL master收到dump请求，开始推送binary log给slave（也就是canal）



# 哨兵模式和集群模式对比

## 逻辑架构

- 哨兵模式

  ![img](https://gitee.com/firewolf/allinone/raw/master/images/1350922-20191006122611921-809764078-20220326142520517.png)

- 集群模式

  ![img](https://gitee.com/firewolf/allinone/raw/master/images/1350922-20191006124637992-2055348918-20220326142520760.png)

## spring连接方式

- 单机模式
  - spring.redis.host   会自动生成RedisConnectionFactory，然后利用template.setConnectionFactory，生成RedisTemplate
- 集群模式
  - spring.redis.cluster.nodes=ip1:port1,ip2:port2...        获取后自行切割解析成Set<HostAnPort> nodes
  - RedisClusterConfiguration.setClusterNodes(nodes)
  - 生成RedisTemplate
  - 请求过程为：
    - 从集群节点列表中随机选择一个节点
    - 从该节点获取一个客户端连接（如果配置了连接池，从连接池中获取），执行命令
    - 如果抛出ClusterRedirectException异常，则跳转到返回的目标节点上执行
    - 如果跳转次数大于配置的值 max-redirects， 则抛出TooManyClusterRedirectionsException异常
- 哨兵模式
  - spring.redis.sentinel.master  和 spring.redis.sentinel.nodes 分别用来配置集群名和哨兵节点，
  - 内部会生成一个JedisSentinelPool，该类的初始化过程中，会对每一个Node尝试构建Jedis对象，通过jedis.sentinelGetMasterAddrByName方法来获取master节点信息
  - 对每一个哨兵节点通过一个 MasterListener 进行监听（Redis的发布订阅功能），订阅哨兵节点`+switch-master`频道，当发生故障转移时，客户端能收到哨兵的通知，通过重新初始化连接池，完成主节点的切换

## 节点失败检测

- 集群模式
  - 各个节点之间有互相的检测，如果超过半数的节点检测失效时，认为该节点失效
- 哨兵模式
  - 一个哨兵发现节点离线，标识为主观下线，如果超过半数哨兵发现节点下线后，会发现主节点切换过程，完成之后，主节点会客观下线

## 数据存储

- 哨兵模式

  - 集群中每台redsi服务器的数据相同，浪费内存，数据同步采用主从赋值

- 集群模式

  - 实现了redis的分布式存储，每天redis节点上存储不同的内容



# 项目使用redis的地方

## 缓存

基础信息的查询加速：人员、设备、时间计划、区域等

## 分布式锁

Redission，缓存过期时间，30s ~ 1d 不等，识别ppl中判断陌生人次数为3



# Redis CPU 负载高肯能的原因

- 客户的业务负载过重，qps过高，导致CPU被用满，排查方法请参考[排查QPS是否过高](https://support.huaweicloud.com/trouble-dcs/dcs-trouble-0715002.html#dcs-trouble-0715002__section8519162751218)。

- 使用了keys等消耗资源的命令，排查及处理措施请参考[查找并禁用高消耗命令](https://support.huaweicloud.com/trouble-dcs/dcs-trouble-0715002.html#dcs-trouble-0715002__section6300145853215)。

- 发生Redis的持久化重写操作，排查及处理措施请参考[是否存在Redis的持久化重写操作](https://support.huaweicloud.com/trouble-dcs/dcs-trouble-0715002.html#dcs-trouble-0715002__section6314242121514)。


# Redis事务

不保障原子性，某个命令是错误的，则整体失败；正确的命令执行失败，则不会影响其他命令



# Redis的连接池有哪些？

- JedisSentinelPool ： 用于哨兵模式
- JedisPool：通常使用的
- SharedJedisPool：集群使用的，通过一致性hash算法，将不同的key分配到不同的redis server上，达到横向扩展的目的

> 一致性Hash算法：

# 缓存过期策略

## 过期策略

把配置有过期时间的数据在**过期字典**中进行描述：

- 过期字典的键指向 Redis 数据库中的某个 key(键)；
- 过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）

判断是否过期通过如下两种策略：

- **惰性删除** ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除
- **定期删除** ： 每隔一段时间随机抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响，默认10秒扫描一次



## 内存淘汰机制

（1）volatile-lru：使用LRU算法移除key，只对设置了过期时间的键 

（2）allkeys-lru：使用LRU算法移除key 

（3）volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键 

（4）allkeys-random：移除随机的key 

（5）volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key 

（6）noeviction：不进行移除。针对写操作，只是返回错误信息 



# Redis数据结构

## 对象数据结构

- strings
- sets
- lists
- zsets
- hashs

## 底层数据结构

### SDS（简单动态字符串）

- 记录字符串长度，O(1) 时间复杂度可返回长度
- 内存重分配少
  - 空间预分配
  - 惰性空间释放
- 二进制安全

### 双端链表

- 双向指针：pre、next
- 有头尾节点：head、tail
- 存储链表长度，O(1)返回节点个数

### 压缩链表（ziplist）

- 列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现
- 每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成
- 添加元素或者删除节点可能会导致连锁更新（后面节点中previous_entry_length子段）

### 字典

- 包含两个hash表，通常只使用一个hash表(ht[2])，
- 在进行rehash的时候，会把一个hash表中的数据，转存到另外一个hash表，如此往复，过程会有渐进式rehash

### 跳跃表(skiplist)

- 支持在 O(logN) 的时间复杂度里查找到对应的节点。
- Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。



## 对象数据结构与底层数据结构映射

strings：sds

lists：ziplist、双端链表

hashs：ziplist、字典

sets：字典

zsets：ziplist、skiplist



# Redis 为什么快？

1. 基于内存实现（最主要），不受磁盘I/O开销的限制

2. 高效的数据结构：压缩链表、动态字符串、跳跃表

3. 合理的数据编码

   相同的数据类型，在不同场景下，编码不同，如：

   - **String**：存储数字的话，采用int类型的编码，如果是非数字的话，采用 raw 编码；
   - **List**：字符串长度及元素个数小于一定范围使用 ziplist 编码，任意条件不满足，则转化为 linkedlist 编码；
   - **Hash**：hash 对象保存的键值对内的键和值字符串长度小于一定值及键值对；
   - **Set**：保存元素为整数及元素个数小于一定范围使用 intset 编码，任意条件不满足，则使用 hashtable 编码；
   - **Zset**：zset 对象中保存的元素个数小于及成员长度小于一定值使用 ziplist 编码，任意条件不满足，则使用 skiplist 编码

4. 合理的线程模型

   - 多路复用
   - 单线程模型，避免上下文切换

5. 空间扩容/收缩采用渐进式rehash



# 渐进式rehash

rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。

一次性将这些键值对全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。

渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

步骤如下：

1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
3. 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
4. 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。



# 跳跃表和B+树区别

### 跳跃表优点

- 维持数据平衡的成本比较低，完全依靠随机（一个节点是否要提到上一层，完全是随机决定），B+树需要通过节点旋转完成

### B+树优点

- 有双向指针
- 更善于做磁盘I/O（页大小）
- 高度较低，性能比跳跃表更稳定

## 底层原理

原理就是对一个key进行k个hash算法获取k个值，在比特数组中将这k个值散列后设定为1，然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该key存在。

布隆过滤器可能会误判，如果它说不存在那肯定不存在，如果它说存在，那数据有可能实际不存在；

Redis的bitmap只支持2^32大小，对应到内存也就是512MB，误判率万分之一，可以放下2亿左右的数据，性能高，空间占用率极小，省去了大量无效的数据库连接。

因此我们可以通过布隆过滤器，将Redis缓存穿透控制在一个可容范围内。

在Redis中，使用bitmap来实现布隆过滤器



# Redis 持久化

## RDB

### 原理

在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。

Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。

> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。

### 触发时机

1. 满足了配置条件

   默认设置了三个时机，只要有任意一个满足，就会触发保存，如果想不保存，那么可以通过设置成save ""来实现

   ```properties
   save 900 1
   save 300 10
   save 60 10000
   ```

2. save命令

   save时只管保存，其它不管，全部阻塞

3. bgsave命令

   Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间

4. flushall命令

   会情况所有的数据

### 使用场景

- 大规模的数据恢复，性能较高
- 对数据完整性和一致性要求不高



## AOF

### 原理

以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。更新时间默认是1秒

#### rewrite机制

AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof

**实现原理**

AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。

**触发时机**

Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。



### 损坏了怎么处理？

可以使用redis-check-aof --fix [aof文件名] 进行修复。



### 同步策略

使用appendsync 属性进行配置，有三个取值

- ayways （每修改同步）：  同步持久化，每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好
- everysec （异步操作）：每秒记录，如果一秒内宕机，有数据丢失
- no（从不同步）:



## 如何选择

- dump.rdb和appendonly.aof可以同时存在，启动的时候会先加载appendonly.aof
- AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大
- 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.
- 同时开启两种持久化方式：在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.

RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。

因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。 

