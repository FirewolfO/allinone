[toc]

# 项目关注点

## 项目业务、架构、负责了什么？



## 设计了什么？有没有什么问题



## 项目中遇到的问题

### OOM排查

- 对RocketMQ 的消费部门做了封装，为了实现链路追踪，我们把traceId存储到了threadlocal
- 在消费结束的时候，调用threadlocal.remove()对存储的数据进行了移除
- 然而，在Rocket底层使用的Netty中，在ObjectCleaner中存储了一个LIVE_SET，里面存储的是AutomaticCleanerReference（弱引用）的Set集合，消费线程会把FastThreadLocal保存起来，等消费线程结束之后，进行清除这些FastThreadLocal，然而由于ThreadLocal被清理掉，导致threadLocalMap.isCleanerFlagSet(index)为false。从而导致Netty里面的ThreadLocal不能被回收
- 解决：定义自己的ThrealLocal类型，清除的时候，进行判断



### 数据看板通过业务主动注册接口来完成数据查询

- 也可以，缺点：如果这个时间调用不同，就查不到相应的数据，如果使用MQ解耦，可以看到旧数据



### 你认为你做架构师的话，需要有哪些能力，自己的不足

- 系统架构、技术架构、具体的技术问题、技术攻关、资源分配



# 一致性Hash算法

> 参考文献：https://www.jianshu.com/p/528ce5cd7e8f

核心思想：

- 对要进行hash定位的数据，使用 2 32 -1进行 hash，而不是节点的数据；
- 对所有的节点也使用 2 32 - 1 进行hash
- 数据存放在最近的下一个节点的位置

 ![image-20220330171631320](https://gitee.com/firewolf/allinone/raw/master/images/image-20220330171631320.png)

- 为了解决节点少导致的倾斜问题，引入虚拟节点，同时让实际节点和虚拟节点之间形成一个映射关系（虚拟节点越多，数据分布越均匀）

   ![image-20220330171804031](https://gitee.com/firewolf/allinone/raw/master/images/image-20220330171804031.png)

<font color=red>其实，并不仅仅局限于数据往分布式节点存放的场景，对于普通的容器，如数组，也可以采用类似的方式来实现</font>



# 服务调用

## Http VS RPC

### RPC

#### 架构

 ![image-20220420163946394](https://gitee.com/firewolf/allinone/raw/master/images/image-20220420163946394.png)

一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub。分别说说这几个组件：

- 客户端（Client），服务的调用方。
- 服务端（Server），真正的服务提供者。
- 客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
- 服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

#### 流行RPC框架

- gRPC：google
- Thrift：facebook
- Dubbo：阿里

#### 优劣势

- 方便协议扩展
- 对TCP协议封装较少，效率高；
- 一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作
- 更适合较为复杂的系统架构
- 支持同步调用和异步调用
- 对客户端和服务端的语言要求统一

### Http

- 通用http协议，使用简单直接

- 语言无要求

  

# 服务协调（服务注册、分布式配置）

## Eureka、Nacos、Zookeeper

1. Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
2. 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
3. Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时
4. Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式； Eureka 采用 AP 方式
5. ZK保证CP

ZooKeeper 集群中包含 Leader、Follower 以及 Observer 三个角色：

- Leader：负责进行投票的发起和决议，更新系统状态，Leader 是由选举产生;
- Follower： 用于接受客户端请求并向客户端返回结果，在选主过程中参与投票;
- Observer：可以接受客户端连接，接受读写请求，写请求转发给 Leader，但 Observer 不参加投票过程，只同步 Leader 的状态，Observer 的目的是为了扩展系统，提高读取速度。



## PAX_OS 协议

### 缺点



# 网络

## TCP/IP模型

通常可以被分为七层、四层、五层等

 ![image-20220420163642012](https://gitee.com/firewolf/allinone/raw/master/images/image-20220420163642012.png)

## 三次握手、四次挥手过程及TCP状态变化

### 三次握手

1. 第一次握手：建立连接时，客户端发送SYN包（syn=1）到服务器，并进入SYN_SENT状态，等待服务器确认。
2. 第二次握手：服务器收到SYN包，必须确认客户端的SYN包（ack=x+1），同时自己也发送一个SYN包（syn=1），即SYN+ACK包，此时服务器进入SYN_RECV状态。
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

> 至此，TCP连接就建立了，客户端和服务器可以愉快地“玩耍”了。只要通信双方没有一方发出连接释放的请求，连接就将一直保持。如果有一方释放连接，就会发起挥手操作。

### 四次挥手

- 第一次挥手：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文头部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN_WAIT_1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

- 第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务器就进入了CLOSE_WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器方向的连接就被释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接收。这个状态还要持续一段时间，也就是整个CLOSE_WAIT状态持续的时间。

  > 客户端收到服务器的确认请求后，客户端就进入FIN_WAIT_2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接收服务器发送的最后的数据）。

- 第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME_WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2×MSL（最长报文段寿命）的时间，当客户端撤销相应的TCB（Transmit Control Block，传输控制模块）后，才进入CLOSED状态。

> 最后，服务器只要收到了客户端发出的确认，就立即进入CLOSED状态。同样，撤销TCB后，就结束了这次TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220405124121692.png" alt="image-20220405124121692" style="zoom:150%;" />



# 分布式事务

## 分布式事务场景

- 跨JVM
- 垮数据库
- 跨服务

## 强一致性方案

### DTP模型

#### 架构流程

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220420174100728.png" alt="image-20220420174100728" style="zoom:60%;" />

#### 核心概念

- 事务：一个事务就是一个完整的工作单元，具备ACID特性。
- 全局事务：由事务管理器管理的事务，能够一次性操作多个资源管理器。
- 分支事务：由事务管理器管理的全局事务中，每个资源管理器中独立执行的事务。
- 控制线程：执行全局事务的线程，这个线程用来关联应用程序、事务管理器和资源管理器三者之间的关系，也就是表示全局事务和分支事务的关系，通常称为事务上下文环境



### 2PC模型

#### 流程

1. **Prepare阶段**

   在Prepare阶段，事务管理器给每个参与全局事务的资源管理器发送Prepare消息，资源管理器（单个）要么返回失败，要么在本地执行相应的事务，将事务写入本地的Redo Log文件和Undo Log文件，此时，事务并没有提交

2. **Commit阶段**

   如果事务管理器收到了参与全局事务的资源管理器返回的失败消息，则直接给Prepare阶段执行成功的资源管理器发送回滚消息，否则，向每个资源管理器发送Commit消息。相应的资源管理器根据事务管理器发送过来的消息指令，执行对应的事务回滚或事务提交操作，并且释放事务处理过程中使用的锁资源。

#### 存在问题

- 同步阻塞问题：事务的执行过程中，所有参与事务的节点都会对其占用的公共资源加锁，导致其他访问公共资源的进程或者线程阻塞。
- 单点故障问题：如果事务管理器发生故障，则资源管理器会一直阻塞。
- 数据不一致问题：如果在Commit阶段，由于网络或者部分资源管理器发生故障，导致部分资源管理器没有接收到事务管理器发送过来的Commit消息，会引起数据不一致的问题。
- 无法解决的问题：如果在Commit阶段，事务管理器发出Commit消息后宕机，并且唯一接收到这条Commit消息的资源管理器也宕机了，则无法确认事务是否已经提交。



### 3PC模型

参考文献：https://blog.csdn.net/qq_31960623/article/details/116429261

3PC模型是指三阶段提交模型，是在2PC模型的基础上改进的版本。3PC模型把2PC模型中的Prepare阶段一分为二，最终形成3个阶段：CanCommit阶段、PreCommit阶段和doCommit或者doRollback阶段

#### 流程

1. **CanCommit阶段**

   事务参与者并不真实获取锁占用资源，只是对自身执行事务状态的检查，查看是否具备执行事务的条件，进而回复询问

2. **PreCommit阶段**

   在第一阶段所有参与者都 Ready，那么协调者就会向参与者发送本地执行的相关指令，这部分和 2PC 的第一阶段非常相似，参与者收到指令后进行本地事务执行，并记录日志，并且对处理结果反馈到协调者，来做决策

3. **DoCommit阶段**

   在 PreCommit 之后参与者全部完成本地事务执行但是没有提交，并且都给协调者 ACK 回复，这时协调者认为万事俱备只欠东风了，在 DoCommit 阶段协调者向参与者发送提交指令，参与者收到之后开始执行本地提交，并反馈结果，最终完成这次事务

#### 存在问题

- 与2PC模型相比，3PC模型主要解决了单点故障问题，并减少了事务执行过程中产生的阻塞现象。
- 如果资源管理器无法及时收到来自事务管理器发出的消息，那么资源管理器就会执行提交事务的操作，而不是一直持有事务的资源并处于阻塞状态，但是这种机制会导致数据不一致的问题。
- 如果由于网络故障等原因，导致资源管理器没有及时收到事务管理器发出的Abort消息，则资源管理器会在一段时间后提交事务，这就导致与其他接收到Abort消息并执行了事务回滚操作的资源管理器的数据不一致。



## 最终一致性方案

### TCC

TCC操作服务模式主要包括3个阶段，分别为Try阶段（尝试业务执行）、Confirm阶段（确定业务执行）和Cancel阶段（取消业务执行），

1. **Try阶段**
   - 完成所有业务的一致性检查。
   - 预留必要的业务资源，并需要与其他操作隔离。
2. **Confirm阶段**
   - 此阶段会真正执行业务操作。
   - 因为在Try阶段完成了业务的一致性检查，所以此阶段不会做任何业务检查。
   - 只用Try阶段预留的业务资源进行操作。
   - 此阶段的操作需要满足幂等性。
3. **Cancel阶段**
   - 释放Try阶段预留的业务资源。
   - 此阶段的操作需要满足幂等性。



### 最大努力通知

- 本地消息表

- 独立消息服务

### XA



# 高性能

## 如何优化一个接口

- 数据库优化
  - 索引优化
  - 分库分表
- 业务逻辑优化
  - 接口逻辑拆分，去除不必要逻辑
  - 代码重构
- 技术优化
  - 异步及多线程编程
  - 增加缓存
  - MQ解耦
  - 锁粒度优化

