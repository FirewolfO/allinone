[toc]

# 项目关注点

## 项目业务、架构、负责了什么？



## 设计了什么？有没有什么问题



## 项目中遇到的问题

### OOM排查

- 对RocketMQ 的消费部门做了封装，为了实现链路追踪，我们把traceId存储到了threadlocal
- 在消费结束的时候，调用threadlocal.remove()对存储的数据进行了移除
- 然而，在Rocket底层使用的Netty中，在ObjectCleaner中存储了一个LIVE_SET，里面存储的是AutomaticCleanerReference（弱引用）的Set集合，消费线程会把FastThreadLocal保存起来，等消费线程结束之后，进行清除这些FastThreadLocal，然而由于ThreadLocal被清理掉，导致threadLocalMap.isCleanerFlagSet(index)为false。从而导致Netty里面的ThreadLocal不能被回收
- 解决：定义自己的ThrealLocal类型，清除的时候，进行判断



### 数据看板通过业务主动注册接口来完成数据查询

- 也可以，缺点：如果这个时间调用不同，就查不到相应的数据，如果使用MQ解耦，可以看到旧数据



### 你认为你做架构师的话，需要有哪些能力，自己的不足

- 系统架构、技术架构、具体的技术问题、技术攻关、资源分配



# 一致性Hash算法

> 参考文献：https://www.jianshu.com/p/528ce5cd7e8f

核心思想：

- 对要进行hash定位的数据，使用 2 32 -1进行 hash，而不是节点的数据；
- 对所有的节点也使用 2 32 - 1 进行hash
- 数据存放在最近的下一个节点的位置

 ![image-20220330171631320](https://gitee.com/firewolf/allinone/raw/master/images/image-20220330171631320.png)

- 为了解决节点少导致的倾斜问题，引入虚拟节点，同时让实际节点和虚拟节点之间形成一个映射关系（虚拟节点越多，数据分布越均匀）

   ![image-20220330171804031](https://gitee.com/firewolf/allinone/raw/master/images/image-20220330171804031.png)

<font color=red>其实，并不仅仅局限于数据往分布式节点存放的场景，对于普通的容器，如数组，也可以采用类似的方式来实现</font>



# 服务调用

## Http VS RPC

### RPC

#### 架构

 ![image-20220420163946394](https://gitee.com/firewolf/allinone/raw/master/images/image-20220420163946394.png)

一个完整的RPC架构里面包含了四个核心的组件，分别是Client ,Server,Client Stub以及Server Stub。分别说说这几个组件：

- 客户端（Client），服务的调用方。
- 服务端（Server），真正的服务提供者。
- 客户端存根，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。
- 服务端存根，接收客户端发送过来的消息，将消息解包，并调用本地的方法。

#### 流行RPC框架

- gRPC：google
- Thrift：facebook
- Dubbo：阿里

#### 优劣势

- 方便协议扩展
- 对TCP协议封装较少，效率高；
- 一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作
- 更适合较为复杂的系统架构
- 支持同步调用和异步调用
- 对客户端和服务端的语言要求统一

### Http

- 通用http协议，使用简单直接

- 语言无要求

  

# 服务协调（服务注册、分布式配置）

## Eureka、Nacos、Zookeeper

1. Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
2. 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
3. Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时
4. Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式； Eureka 采用 AP 方式
5. ZK保证CP

ZooKeeper 集群中包含 Leader、Follower 以及 Observer 三个角色：

- Leader：负责进行投票的发起和决议，更新系统状态，Leader 是由选举产生;
- Follower： 用于接受客户端请求并向客户端返回结果，在选主过程中参与投票;
- Observer：可以接受客户端连接，接受读写请求，写请求转发给 Leader，但 Observer 不参加投票过程，只同步 Leader 的状态，Observer 的目的是为了扩展系统，提高读取速度。



## PAX_OS 协议

### 缺点



# 网络

## TCP/IP模型

通常可以被分为七层、四层、五层等

 ![image-20220420163642012](https://gitee.com/firewolf/allinone/raw/master/images/image-20220420163642012.png)

## 三次握手、四次挥手过程及TCP状态变化

### 三次握手

1. 第一次握手：建立连接时，客户端发送SYN包（syn=1）到服务器，并进入SYN_SENT状态，等待服务器确认。
2. 第二次握手：服务器收到SYN包，必须确认客户端的SYN包（ack=x+1），同时自己也发送一个SYN包（syn=1），即SYN+ACK包，此时服务器进入SYN_RECV状态。
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

> 至此，TCP连接就建立了，客户端和服务器可以愉快地“玩耍”了。只要通信双方没有一方发出连接释放的请求，连接就将一直保持。如果有一方释放连接，就会发起挥手操作。

### 四次挥手

- 第一次挥手：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文头部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN_WAIT_1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

- 第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务器就进入了CLOSE_WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器方向的连接就被释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接收。这个状态还要持续一段时间，也就是整个CLOSE_WAIT状态持续的时间。

  > 客户端收到服务器的确认请求后，客户端就进入FIN_WAIT_2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接收服务器发送的最后的数据）。

- 第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME_WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2×MSL（最长报文段寿命）的时间，当客户端撤销相应的TCB（Transmit Control Block，传输控制模块）后，才进入CLOSED状态。

> 最后，服务器只要收到了客户端发出的确认，就立即进入CLOSED状态。同样，撤销TCB后，就结束了这次TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220405124121692.png" alt="image-20220405124121692" style="zoom:150%;" />



# 分布式事务

## 分布式事务场景

- 跨JVM
- 垮数据库
- 跨服务

## 强一致性方案（一致性高）

### DTP模型

#### 架构流程

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220420174100728.png" alt="image-20220420174100728" style="zoom:60%;" />

#### 核心概念

- 事务：一个事务就是一个完整的工作单元，具备ACID特性。
- 全局事务：由事务管理器管理的事务，能够一次性操作多个资源管理器。
- 分支事务：由事务管理器管理的全局事务中，每个资源管理器中独立执行的事务。
- 控制线程：执行全局事务的线程，这个线程用来关联应用程序、事务管理器和资源管理器三者之间的关系，也就是表示全局事务和分支事务的关系，通常称为事务上下文环境

#### 核心组件

在DTP模型中，主要定义了3个核心组件，分别为AP、TM、RM。

- AP：应用程序（Application Program：可以理解为参与DTP分布式事务模型的应用程序。
- RM：资源管理器（Resource Manager）：可以理解为数据库管理系统或消息服务管理器。应用程序可以通过资源管理器对相应的资源进行有效的控制。相应的资源需要实现XA定义的接口。
- TM：事务管理器（Transaction Manager）负责协调和管理DTP模型中的事务，为应用程序提供编程接口，同时管理资源管理器。

### 2PC模型

#### 执行流程

1. **Prepare阶段**

   在Prepare阶段，事务管理器给每个参与全局事务的资源管理器发送Prepare消息，资源管理器（单个）要么返回失败，要么在本地执行相应的事务，将事务写入本地的Redo Log文件和Undo Log文件，此时，事务并没有提交

2. **Commit阶段**

   如果事务管理器收到了参与全局事务的资源管理器返回的失败消息，则直接给Prepare阶段执行成功的资源管理器发送回滚消息，否则，向每个资源管理器发送Commit消息。相应的资源管理器根据事务管理器发送过来的消息指令，执行对应的事务回滚或事务提交操作，并且释放事务处理过程中使用的锁资源。

#### 存在问题

- 同步阻塞问题：事务的执行过程中，所有参与事务的节点都会对其占用的公共资源加锁，导致其他访问公共资源的进程或者线程阻塞。
- 单点故障问题：如果事务管理器发生故障，则资源管理器会一直阻塞。
- 数据不一致问题：如果在Commit阶段，由于网络或者部分资源管理器发生故障，导致部分资源管理器没有接收到事务管理器发送过来的Commit消息，会引起数据不一致的问题。
- 无法解决的问题：如果在Commit阶段，事务管理器发出Commit消息后宕机，并且唯一接收到这条Commit消息的资源管理器也宕机了，则无法确认事务是否已经提交。



### 3PC模型

参考文献：https://blog.csdn.net/qq_31960623/article/details/116429261

3PC模型是指三阶段提交模型，是在2PC模型的基础上改进的版本。3PC模型把2PC模型中的Prepare阶段一分为二，最终形成3个阶段：CanCommit阶段、PreCommit阶段和doCommit或者doRollback阶段

#### 执行流程

1. **CanCommit阶段**

   事务参与者并不真实获取锁占用资源，只是对自身执行事务状态的检查，查看是否具备执行事务的条件，进而回复询问

2. **PreCommit阶段**

   在第一阶段所有参与者都 Ready，那么协调者就会向参与者发送本地执行的相关指令，这部分和 2PC 的第一阶段非常相似，参与者收到指令后进行本地事务执行，并记录日志，并且对处理结果反馈到协调者，来做决策

3. **DoCommit阶段**

   在 PreCommit 之后参与者全部完成本地事务执行但是没有提交，并且都给协调者 ACK 回复，这时协调者认为万事俱备只欠东风了，在 DoCommit 阶段协调者向参与者发送提交指令，参与者收到之后开始执行本地提交，并反馈结果，最终完成这次事务

#### 存在问题

- 与2PC模型相比，3PC模型主要解决了单点故障问题，并减少了事务执行过程中产生的阻塞现象。
- 如果资源管理器无法及时收到来自事务管理器发出的消息，那么资源管理器就会执行提交事务的操作，而不是一直持有事务的资源并处于阻塞状态，但是这种机制会导致数据不一致的问题。
- 如果由于网络故障等原因，导致资源管理器没有及时收到事务管理器发出的Abort消息，则资源管理器会在一段时间后提交事务，这就导致与其他接收到Abort消息并执行了事务回滚操作的资源管理器的数据不一致。

### AT模式

是2PC 的变成，在分布式事务seata中采用的方式

- 一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。
- 二阶段：
  - 提交异步化，非常快速地完成。
  - 回滚通过一阶段的回滚日志进行反向补偿。

和常规的2PC相比区别在于，<font color=red>第一阶段会进行提交</font>



## 最终一致性方案（性能高）

### 基本要求

#### 可查询操作

可查询操作服务模式需要服务的操作具有可标识性，主要体现在服务的操作具有全局唯一的标识。

#### 幂等性

幂等操作服务模式要求操作具有幂等性。幂等性是数学上的概念，指的是使用相同的参数执行同一个方法时，无论执行多少次，都能输出相同的结果。

### TCC模式

TCC操作服务模式主要包括3个阶段，分别为Try阶段（尝试业务执行）、Confirm阶段（确定业务执行）和Cancel阶段（取消业务执行）

#### 执行流程

1. **Try阶段**
   - 完成所有业务的一致性检查。
   - 预留必要的业务资源，并需要与其他操作隔离。
2. **Confirm阶段**
   - 此阶段会真正执行业务操作。
   - 因为在Try阶段完成了业务的一致性检查，所以此阶段不会做任何业务检查。
   - 只用Try阶段预留的业务资源进行操作。
   - 此阶段的操作需要满足幂等性。
3. **Cancel阶段**
   - 释放Try阶段预留的业务资源。
   - 此阶段的操作需要满足幂等性。

#### 优缺点

- 在应用层实现具体逻辑，锁定资源的粒度变小，不会锁定所有资源，提升了系统的性能。
- Confirm阶段和Cancel阶段的方法具备幂等性，能够保证分布式事务执行完毕后数据的一致性。
- TCC分布式事务解决方案由主业务发起整个事务，无论是主业务还是分支事务所在的业务，都能部署为集群模式，从而解决了XA规范的单点故障问题。

#### 注意事项

##### 空回滚

- 产生原因：出现空回滚的原因是一个分支事务所在的服务器宕机或者网络发生异常，此分支事务调用失败，此时并未执行此分支事务Try阶段的方法。当服务器或者网络恢复后，TCC分布式事务执行回滚操作，会调用分支事务Cancel阶段的方法，如果Cancel阶段的方法不能处理这种情况，就会出现空回滚问题。

- 解决方案：在主业务发起全局事务时，生成全局事务记录，并为全局事务记录生成一个全局唯一的ID，叫作全局事务ID。这个全局事务ID会贯穿整个分布式事务的执行流程。再创建一张分支事务记录表，用于记录分支事务，将全局事务ID和分支事务ID保存到分支事务表中。执行Try阶段的方法时，会向分支事务记录表中插入一条记录，其中包含全局事务ID和分支事务ID，表示执行了Try阶段。当事务回滚执行Cancel阶段的方法时，首先读取分支事务表中的数据，如果存在Try阶段插入的数据，则执行正常操作回滚事务，否则为空回滚，不做任何操作。

##### 幂等问题

- 产生原因：由于服务器宕机、应用崩溃或者网络异常等原因，可能会出现方法调用超时的情况，为了保证方法的正常执行，往往会在TCC方案中加入超时重试机制。因为超时重试有可能导致数据不一致的问题，所以需要保证分支事务的执行以及TCC方案的Confirm阶段和Cancel阶段具备幂等性。

- 解决方案：在分支事务记录表中增加事务的执行状态，每次执行分支事务以及Confirm阶段和Cancel阶段的方法时，都查询此事务的执行状态，以此判断事务的幂等性。

##### 悬挂问题

- 产生原因：在TCC分布式事务中，通过RPC调用分支事务Try阶段的方法时，会先注册分支事务，再执行RPC调用。如果此时发生服务器宕机、应用崩溃或者网络异常等情况，RPC调用就会超时。如果RPC调用超时，事务管理器会通知对应的资源管理器回滚事务。可能资源管理器回滚完事务后，RPC请求达到了参与分支事务所在的业务方法，因为此时事务已经回滚，所以在Try阶段预留的资源就无法释放了。这种情况，就称为悬挂。总之，悬挂问题就是预留业务资源后，无法继续往下处理
- 解决方案：思路是如果执行了Confirm阶段或者Cancel阶段的方法，则Try阶段的方法就不能再执行。具体方案是在执行Try阶段的方法时，判断分支记录表中是否已经存在同一全局事务下Confirm阶段或者Cancel阶段的事务记录，如果存在，则不再执行Try阶段的方法



### 可靠消息最终一致性解决方案

可靠消息最终一致性分布式事务解决方案指的是事务的发起方执行完本地事务之后，发出一条消息，事务的参与方，也就是消息的消费者一定能够接收到这条消息并处理成功。这个方案强调的是<font color=red>只要事务发起方将消息发送给事务参与方，事务参与方就一定能够执行成功，事务最终达到一致的状态</font>。



### 最大努力通知型解决方案

当分布式事务跨越多个不同的系统，尤其是不同企业之间的系统时，解决分布式事务问题就需要用到最大努力通知型方案。



> #### 最大努力通知与可靠消息最终一致性的区别
>
> 最大努力通知型方案和可靠消息最终一致性方案有着本质的不同，主要体现在设计不同、业务场景不同和解决的问题不同3个方面。
>
> **1.设计不同**
>
> 1）可靠消息最终一致性方案需要事务发起方一定要将消息发送成功。
>
> 2）最大努力通知型方案中，业务主动方尽最大努力将消息通知给业务被动方，但消息可能会丢失，业务被动方不一定能够接收到消息。
>
> 

## 分布式事务规范

### XA



### JTA



# 高性能

## 如何优化一个接口

- 数据库优化
  - 索引优化
  - 分库分表
- 业务逻辑优化
  - 接口逻辑拆分，去除不必要逻辑
  - 代码重构
- 技术优化
  - 异步及多线程编程
  - 增加缓存
  - MQ解耦
  - 锁粒度优化



# 服务拆分

## 拆分时机

- 为了快速迭代
- 高并发场景
- 功能复用
- 较大团队代码冲突

## 拆分原则

- 服务之间不要有交叉业务
- 高内聚低耦合
- 粒度要适中，演进式拆分；
- 接口的定义要保证扩展性（如：用对象代替基础数据类型）和幂等性



# DDD

领域驱动设计（Domain Driven Design），是一种拆解业务、划分业务、确定业务边界的方法，是一种领域设计思想。

- 核心思想：建立领域模型，领域模型处于架构的核心位置。
- 核心目标：避免业务逻辑的复杂度与技术实现的复杂度混淆在一起。

贫血模型：对象只有数据字段，和业务之间是割裂的，无法知道会用来干什么，会出现贫血失忆症

充血模型：让一个对象同时拥有状态（数据）和行为（方法），这样，有哪些业务会一目了然；



# 系统性能工具

## Linux命令

- 网络
  - iftop：流量排序工具

- 磁盘IO
  - iotop
- 磁盘使用情况
  - du -sh 
  - fdisk
- CPU消耗
  - top
- 服务器稳定性
  - uptime：服务器各次启动时间



## 监控平台

- grafana



# Base理论

- BASE 是基本可用（Basically Available）
- 软状态（Soft State）
- 最终一致性（Eventually Consistent）



# 规则引擎

1. Drools Java 语言编写的开放源码规则引擎，基于Apache协议，基于RETE算法，于2005年被JBoss收购，用来减少硬编码还是不错的。
2. Easy Rules：提供了规则抽象来创建带有条件和操作的规则，以及运行一组规则来评估条件和执行操作的RulesEngine API。相对易于学习的API。并且支持创建复合规则。能够使用表达式语言定义规则
3. Ilog JRules： IBM WebSphere ILOG JRules 是一个业务规则管理平台，它尽可能减少了研发人员的参与。顺道提供了一整套全生命周期管理工具。

