# 1、算法介绍

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

# 2、算法描述

- 找出待排序的数组中最大和最小的元素；
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
- 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

# 3、算法动画

![基数](https://gitee.com/firewolf/allinone/raw/master/images/基数.gif)

# 4、算法代码

public static void sort(int[] arr) {

​    int min, max;

​    min = max = arr[0];

​    //找出最大值和最小值

​    for (int i = 1; i < arr.length; i++) {

​        if (arr[i] > max)

​            max = arr[i];

​        if (arr[i] < min)

​            min = arr[i];

​    }

​    //算出数组长度，最大值-最小值+1

​    int length = max - min + 1; //数组长度

​    int offset = min;

​    int[] countArr = new int[length];

​    for (int i = 0; i < arr.length; i++) {

​        countArr[arr[i] - offset] = countArr[arr[i] - offset] + 1;

​    }

​    int tmp = 0;

​    for (int i = 0; i < countArr.length; i++) {

​        if (countArr[i] != 0) {

​            for (int j = 1; j <= countArr[i]; j++) {

​                arr[tmp++] = i + offset;

​            }

​        }

​    }

}

# 5、算法分析

计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

**其实，计数排序就是用另外一个数组来记录哪些数据出现了，哪些没有出现，从而进行排序**。