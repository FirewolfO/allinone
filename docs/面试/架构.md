[toc]

# 项目业务、架构、负责了什么？



# 设计了什么？有没有什么问题



# 项目中遇到的问题

## OOM排查

- 对RocketMQ 的消费部门做了封装，为了实现链路追踪，我们把traceId存储到了threadlocal
- 在消费结束的时候，调用threadlocal.remove()对存储的数据进行了移除
- 然而，在Rocket底层使用的Netty中，在ObjectCleaner中存储了一个LIVE_SET，里面存储的是AutomaticCleanerReference（弱引用）的Set集合，消费线程会把FastThreadLocal保存起来，等消费线程结束之后，进行清除这些FastThreadLocal，然而由于ThreadLocal被清理掉，导致threadLocalMap.isCleanerFlagSet(index)为false。从而导致Netty里面的ThreadLocal不能被回收
- 解决：定义自己的ThrealLocal类型，清除的时候，进行判断



# 数据看板通过业务主动注册接口来完成数据查询

- 也可以，缺点：如果这个时间调用不同，就查不到相应的数据，如果使用MQ解耦，可以看到旧数据



# 你认为你做架构师的话，需要有哪些能力，自己的不足

- 系统架构、技术架构、具体的技术问题、技术攻关、资源分配



# 一致性Hash算法

> 参考文献：https://www.jianshu.com/p/528ce5cd7e8f

核心思想：

- 对要进行hash定位的数据，使用 2 32 -1进行 hash，而不是节点的数据；
- 对所有的节点也使用 2 32 - 1 进行hash
- 数据存放在最近的下一个节点的位置

 ![image-20220330171631320](https://gitee.com/firewolf/allinone/raw/master/images/image-20220330171631320.png)

- 为了解决节点少导致的倾斜问题，引入虚拟节点，同时让实际节点和虚拟节点之间形成一个映射关系（虚拟节点越多，数据分布越均匀）

   ![image-20220330171804031](https://gitee.com/firewolf/allinone/raw/master/images/image-20220330171804031.png)

<font color=red>其实，并不仅仅局限于数据往分布式节点存放的场景，对于普通的容器，如数组，也可以采用类似的方式来实现</font>



# PAX_OS 协议缺点





# Eureka、Nacos、Zookeeper

1. Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
2. 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
3. Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时
4. Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式； Eureka 采用 AP 方式
5. ZK保证CP

ZooKeeper 集群中包含 Leader、Follower 以及 Observer 三个角色：

- Leader：负责进行投票的发起和决议，更新系统状态，Leader 是由选举产生;
- Follower： 用于接受客户端请求并向客户端返回结果，在选主过程中参与投票;
- Observer：可以接受客户端连接，接受读写请求，写请求转发给 Leader，但 Observer 不参加投票过程，只同步 Leader 的状态，Observer 的目的是为了扩展系统，提高读取速度。

