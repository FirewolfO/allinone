[toc]

# 索引概述

## 定义

MySQL官方对索引的定义为：**索引（**Index**）是帮助**MySQL**高效获取数据的数据结构**。

**索引的本质：**索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 

## 优点

1. 提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主要的原因。 
2. 建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 
3. 对于有依赖关系的子表和父表联合查询时，可以提高查询速度。
4. 在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。

## 缺点

1. 创建索引和维护索引要 耗费时间 ，并且随着数据量的增加，所耗费的时间也会增加。
2. 索引需要占 磁盘空间 ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。 
3. 索引大大提高了查询速度，同时却会 降低更新表的速度 



# 索引分类

### 聚簇索引

1. 采用B+树构建索引

   - 使用记录主键值的大小进行记录和页的排序

   - 叶子节点保存完整的用户数据
   - 各层节点之间采用双向指针连接；

2. 优点

   - 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
   - 聚簇索引对于主键的 排序查找 和 范围查找 速度非常快
   - 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 节省了大量的io操作

3. 缺点

   - 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的**ID**列为主键**
   - 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义**主键为不可更新**

### 非聚簇索引（二级索引 | 辅助索引）

1. 特点
   - 叶子节点也不保存具体数据，会存储主键值
   - 如果查找的数据不在索引上，需要通过主键到聚簇索引上通过**回表**来查询数据

### 联合索引

- 多个字段构成的索引；
- 会先根据第一个字段排序，然后根据第二个字段排序



### 主键索引和唯一索引区别

1. 主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
2. 主键创建后一定包含一个唯一性索引，唯一性索引不一定就是主键。
3. 唯一性索引列允许空值， 而主键列不允许为空值。
4. 主键可以被其他表引用为外键，而唯一索引不能。
5. 一个表最多只能创建一个主键，但是可以创建多个唯一索引。
6. 主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。
7. 主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。

> 主键也可以是多个字段，也就是联合主键



# 不同存储引擎索引选择

## InnoDB索引

- 采用B+ 树结构，叶子节点存储的是完整的用户数据
- 有普通记录（ record_type为0）和目录页记录（ record_type为1）之分，都有相应的页目录，用于二分查找加速查询；
- 每页都有一个最大记录和最小记录：
- 内节点中目录项记录的唯一（为了保证这一点，对于非唯一索引，会在内节点也保存主键）



## MyISAM索引

- MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 
- MyISAM索引都是非聚餐索引，但是，由于是用地址查找，所以，速度极快



# 创建索引原则

## 适合创建索引场景

- 字段的数值有唯一性的限制
- 频繁作为 WHERE 条件的字段（查询、删除、修改）
- 经常 GROUP BY 和 ORDER BY 的列
- DISTINCT 字段需要创建索引
- 对于表连接情况，对用于连接条件的列，创建索引
- 使用列的类型小的创建索引
- 使用字符串前缀创建索引
- 区分度高(散列性高)的列适合作为索引 
-  使用最频繁的列放到联合索引的左侧
-  在多个字段都要创建索引的情况下，联合索引优于单值索引 
- 单表不要超过5个索引



## 不适合创建索引场景

- 在where中使用不到的字段
-  数据量小的表
-  有大量重复数据的列
- 避免对经常更新的表创建过多的索引
- 不建议用无序的值作为索引
- 不要定义冗余或重复的索引 



# 索引优化

### 索引失效场景

1. 全值匹配速度最快
2. 最左匹配原则（如果前缀没有匹配上，则无法使用索引）
3.  计算、函数、类型转换(自动或手动)导致索引失效
4. 类型转换会导致索引失效
5.  范围条件右边的列索引会失效
6. 不等于(!= 或者<>)索引失效
7.  is null可以使用索引，is not null无法使用索引
8.  like以通配符%开头索引失效
9. OR 前后存在非索引的列，索引失效

## 其他

1. 尽量做到索引覆盖，避免回表

2. 较长字符串尽量创建前缀索引，指定索引长度

3. join 操作

   - 使用小表驱动大表，减少内循环的次数，可以减少数据加载次数，可以提高连接效率；
   - 在连接字段特别是被驱动表的连接字段上创建索引

   - 设置合理的缓冲区大小能够提高连接效率

4. 普通索引和唯一索引

   - 二者对于查询性能的区别不是很大
   - 对于更新过程，由于change buffer的存在，能够对普通索引的性能有很大优化。
   - 所以，如果不是"更新完后马上查询"的业务模式，建议使用普通索引；

5. 多使用commit

   - 只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放

     的资源而减少。

     - 回滚段上用于恢复数据的信息
     - 被程序语句获得的锁
     - redo / undo log buffer 中的空间
     - 管理上述 3 种资源中的内部花费

6. 使用limit 1 去除全表扫描

   - 针对的是会扫描全表的 SQL 语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。

7. 尽量避免使用 select *

   - MySQL 在解析的过程中，会通过 查询数据字典 将"*"按序转换成所有列名，这会大大的耗费资源和时
   - 无法使用 覆盖索引

8. exists 和 in 

   - 当子查询大于外层查询时，EXISTS比IN效率高
   - 当子查询小于外层查询时，EXISTS比IN效率低;

9. 统计行数的时候，尽量使用count(*)



# Join原理

join 底层采用了Nested-Loop Join 算法，需要区分驱动表和被驱动表，先访问驱动表，筛选出结果集，然后将这个结果集作为循环的基础，访问被驱动表过滤出需要的数据。

分为驱动表和被驱动表，使用嵌套循环。驱动表在外循环，被驱动表在内循环。

### SNLJ，Simple Nested-Loop Join（简单嵌套循环）

这里会扫描 A 表，将记录一行一行地取出来进行匹配。其实就是用 A 的结果集做为外循环，读取每一行都会触发一个内循环（扫描 B 表）。对 B 表的数据进行比较，加入结果集。

### INLJ，Index Nested-Loop Join（索引嵌套循环）

整个算法过程和 SNL 一致，最大的区别在于，用来进行 join 的字段已经在被驱动表中建立了索引。

这样，对内层循环，因为有了索引后，不需要再全表扫描 B 表，而是进行 B 表的索引查询。最终查询和比较的次数大大降低。

### BNLJ，Block Nested-Loop Join（块嵌套循环）

如果 join 的字段有索引，MySQL 会使用 INL 算法。如果没有的话，被驱动表需要进行扫描。这里 MySQL 并不会简单粗暴的应用 SNL 算法，而是加入了 **buffer**  缓冲区，降低了内循环的个数，也就是被驱动表的扫描次数。

这个 **buffer** 被称为 **join buffer**，顾名思义，就是用来缓存 join 需要的字段。MySQL 默认 buffer 大小 256K，如果有 n 个 join 操作，会生成 n-1 个 join buffer

在外层循环扫描 A 中的所有记录。扫描的时候，会把需要进行 join 用到的列都缓存到 buffer 中。buffer 中的数据有一个特点：<font color=blue>里面的记录不需要一条一条地取出来和 B 表进行比较，而是整个 buffer 和 B 表进行批量比较。</font>

<font color=red>如果我们把 buffer 的空间开得很大，可以容纳下 A 表的所有记录，那么 B 表也只需要访问访问一次</font>，反过来说，<font color=green>如果A的结果比较少，访问B表的次数也会变少</font>

### 总结

假设有这样的数据：

- 驱动表为 A，记录数 N；被驱动表为 B，记录数 M。
- 如果 join 字段使用索引，B+ 树的深度为 IndexHeight。匹配的记录数为 M(match)。
- 如果 join 字段不使用索引，使用的 buffer 大小为 `join_buffer_size`，join 字段的总大小为 `used_column_size` 。

效率对比如下：

![image-20220307175158290](https://gitee.com/firewolf/allinone/raw/master/images/image-20220307175158290.png)

总的来说，应用 join 需要注意：

- 用来进行 join 的字段要加索引，会触发 INLJ 算法，如果是主键的聚簇索引，性能最优。
- 如果无法使用索引，那么注意调整 join buffer 大小，适当调大些。
- 小结果集驱动大结果集。用数据量小的表去驱动数据量大的表，这样可以减少内循环个数，也就是被驱动表的扫描次数

参考文献：[Join原理](https://www.jianshu.com/p/6086365a73bd)



# Change Buffer

- 当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。<font color=blue> 在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。</font> 通过这种方式就能保证这个数据逻辑的正确性。
- 虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。
- 将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作.
- <font color=blue>由于更新操作的时候操作的是change buffer，所以，减少了磁盘io；同时，由于数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率</font>
- <font color = red>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用</font>



# count(*)、count(字段)、count(1)、count(主键)

- count(*)在不同引擎下的区别
  - myisam：对于不带where条件的count(*)，由于会记录行数，所以可以在O(1)的时间复杂度内直接返回结果；
  - Innodb：因为增加了版本控制(MVCC)的原因，同时有多个事务访问数据并且有更新操作的时候，每个事务需要维护自己的可见性，那么每个事务查询到的行数也是不同的，所以不能缓存具体的行数，<font color=red>他每次都需要 count 计算一下所有的行数</font>。
- count(*)、count(字段)、count(1)
  - **对于count(主键id)来说**，InnoDB引擎会遍历整张表，把每一行的id值都取出来，返回给server层。server层拿到id后，判断是不可能为空的，就按行累加
  - **对于count(1)来说**，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加
  - **对于count(字段)来说**：
    1. 如果这个“字段”是定义为not null的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；
    2. 如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。
  - **但是count(\*)是例外**，并不会把全部字段取出来，而是专门做了优化，不取值。count(*)肯定不是null，按行累加
  - 总体效率：<font color=red>count(字段)<count(主键id)<count(1)≈count(\*)</font>

参考文献：[MySQL几种Count对比](https://cloud.tencent.com/developer/article/1849824)



# Exists 和 in 

- exists是对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率；
- in是把外表和内表做hash连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表），而内表多大都需要查询，不可避免，故外表大的使用in，可加快效率。
- 总结
  - 当子查询大于外层查询时，EXISTS比IN效率高
  - 当子查询小于外层查询时，EXISTS比IN效率低;



# 索引下推（ICP）

Index Condition Pushdown(ICP)是MySQL 5.6中新特性，是一种在存储引擎层使用索引过滤数据的一种优化方式。ICP可以减少存储引擎访问基表的次数以及MySQL服务器访问存储引擎的次数

### 理解

没有使用ICP的情况下，MySQL是如何查询的：

- 存储引擎读取索引记录；
- 根据索引中的主键值，定位并读取完整的行记录；
- 存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件。

使用ICP的情况下，查询过程如下：

- 存储引擎读取索引记录（不是完整的行记录）；
- 判断`WHERE`条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；
- 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
- 存储引擎把记录交给`Server`层，`Server`层检测该记录是否满足`WHERE`条件的其余部分。

总结：mysql在索引列也在where条件中的时候，会在存储引擎层把不满足条件的数据过滤掉，然后再交给Server层， 从而节省掉不满足条件数据的回表和传递到server层的成本。

### ICP使用条件

1. 只能用于二级索引
2.  并非全部where条件都可以用ICP筛选，如果where条件的字段不在索引列中，还是要读取整表的记录到server端做where过滤
3. ICP可以用于MyISAM和InnnoDB存储引擎
4. 当SQL使用覆盖索引时，不支持ICP优化方法

