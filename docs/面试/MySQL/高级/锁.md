[TOC]

# 并发访问数据的情况

## 读-读

不会引起什么问题，所以，不做任何处理

## 写-写

会覆盖别的事务的写操作，出现脏写的问题，所以如果出现写-写的情况，需要让多个事务排队等待，这个排队等待的过程，通过锁来实现。

锁其实就是内存中的一个结构，在执行事务前本来是没有锁结构和行记录进行关联；当记录要被修改的时候，先看看内存中有没有这个锁结构，如果没有，就生成一个，和这个记录以及事务关联上。

锁结构内容：

- 事务信息
- is_waiting：是否处于等待状态

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220402152523392.png" alt="image-20220402152523392" style="zoom:50%;" />

- 不加锁：不需要在内存中生成和记录关联的锁结构，直接执行操作
- 加锁成功：在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作
- 加锁失败：意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务需要等待，不可以继续执行操作

## 读-写 或 写-读

读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。

<font color=red> MYSQL 在 Repeatable-Read 隔离级别解决了上述读写问题</font>



# 并发问题解决方案

#### 加锁

对读写操作都采用加锁的方式执行

#### 多版本控制（MVCC）

mysql中，普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录

### 对比

- 采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 
- 采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能
- 一般使用mvcc方式来实现



# 锁的分类

## 按操作类型划分

### 读锁（共享锁 / S锁）

针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。

### 写锁（排它锁 / X锁）

当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

## 按锁粒度划分

### 表级锁（Table Lock）

#### 表级S锁、X锁

一般以下两种情况会用到表级S锁和X锁：

- 在数据库崩溃恢复过程中会用到；
- 在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取InnoDB存储引擎提供的表t 的 S锁 或者 X锁 
  - `LOCK TABLES t READ`：对表t加表级S锁
  - `LOCK TABLES t WRITE `：对表t加表级X锁

#### 意向锁（INTENSION LOCK）

InnoDB 支持多粒度锁 ，并允许行级锁和表级锁 共存，而**意向锁**就是其中的一种 表锁 。

- **意向共享锁**（intention shared lock, IS）：事务有意向对表中的某些行加**共享锁**（S锁）
- **意向排他锁**（intention exclusive lock, IX）：事务有意向对表中的某些行加**排他锁**（X锁）

<font color=red>意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁</font>

> 意向锁的并发性
>
> 意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性

#### 自增锁（AUTO_INC锁）

在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性

插入的时候，会有不同的插入模式和锁定模式

##### 插入模式

- 简单插入

  <font color=blue>预先确定要插入的行数 </font>，一般在不带嵌套子查询的的单行插入和多行插入。如：`insert ... values()`

- 批量插入

  <font color=blue>事先不知道要插入的行数</font>，INnoDB在每处理一行的时候，为AUTO_INCREMENT列分配一个新值，通常用于带有子查询的插入或者导入数据。如：`insert ... select ` 或者 `load data`等；

- 混合插入

  这些是”简单插入“语句但是指定部分新行的自动递增值。如`INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d'); `只是执行了部分id值；

##### 锁定模式

会有一个`innodb_autoinc_lock_mode`来对应不同的锁定模式

- `innodb_autoinc_lock_mode = 0`（传统锁定模式）

  所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，保证表中生成的auto_increment为顺序，且<font color=red>在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 限制并发能力。</font>

- `innodb_autoinc_lock_mode = 1`（连续锁定模式）

  "批量插入"模式下，仍然使用AUTO-INC表级锁，并保持到语句结束；

  "简单插入"模式下，则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则和批量插入一样；

  > mysql8.0之前默认模式

- `innodb_autoinc_lock_mode = 2`（交错锁定模式）

  自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），**为任何给定语句插入的行生成的值可能不是连续的。**

  > 只是mysql8.0之后默认值

#### 元数据锁（MDL锁）

MDL是为了保证在读写过程中，表结构不会变化，因此，如下两种情况，都会为表添加MDL锁

- 当对一个表做增删改查操作的时候，加 **MDL读锁；**
- 当要对表做结构变更操作的时候，加 **MDL 写锁**。



### 页级锁

### 行级锁

- 记录锁（Record lock）
- 间隙锁（Gap Lock）
- 临界锁（Next-Key Lock）
- 插入意向锁

## 对待锁的态度

- 悲观锁
- 乐观锁

## 加锁方式

- 隐式锁
- 显式锁

## 其他

- 全局锁





