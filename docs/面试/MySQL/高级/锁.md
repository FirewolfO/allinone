[TOC]

# 并发访问数据的情况

## 读-读

不会引起什么问题，所以，不做任何处理

## 写-写

会覆盖别的事务的写操作，出现脏写的问题，所以如果出现写-写的情况，需要让多个事务排队等待，这个排队等待的过程，通过锁来实现。

锁其实就是内存中的一个结构，在执行事务前本来是没有锁结构和行记录进行关联；当记录要被修改的时候，先看看内存中有没有这个锁结构，如果没有，就生成一个，和这个记录以及事务关联上。

锁结构内容：

- 事务信息
- is_waiting：是否处于等待状态

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220402152523392.png" alt="image-20220402152523392" style="zoom:50%;" />

- 不加锁：不需要在内存中生成和记录关联的锁结构，直接执行操作
- 加锁成功：在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作
- 加锁失败：意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务需要等待，不可以继续执行操作

## 读-写 或 写-读

读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。

<font color=red> MYSQL 在 Repeatable-Read 隔离级别解决了上述读写问题</font>



# 并发问题解决方案

#### 加锁

对读写操作都采用加锁的方式执行

#### 多版本控制（MVCC）

mysql中，普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录

### 对比

- 采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 
- 采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能
- 一般使用mvcc方式来实现



# 锁的分类

## 按操作类型划分

### 读锁（共享锁 / S锁）

针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。

### 写锁（排它锁 / X锁）

当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

## 按锁粒度划分

### 表级锁（Table Lock）

#### 表级S锁、X锁

一般以下两种情况会用到表级S锁和X锁：

- 在数据库崩溃恢复过程中会用到；
- 在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取InnoDB存储引擎提供的表t 的 S锁 或者 X锁 
  - `LOCK TABLES t READ`：对表t加表级S锁
  - `LOCK TABLES t WRITE `：对表t加表级X锁

#### 意向锁（INTENSION LOCK）

InnoDB 支持多粒度锁 ，并允许行级锁和表级锁 共存，而**意向锁**就是其中的一种 表锁 。

- **意向共享锁**（intention shared lock, IS）：事务有意向对表中的某些行加**共享锁**（S锁）
- **意向排他锁**（intention exclusive lock, IX）：事务有意向对表中的某些行加**排他锁**（X锁）

<font color=red>意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁</font>

> 意向锁的并发性
>
> 意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性

#### 自增锁（AUTO_INC锁）

在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性

插入的时候，会有不同的插入模式和锁定模式

##### 插入模式

- 简单插入

  <font color=blue>预先确定要插入的行数 </font>，一般在不带嵌套子查询的的单行插入和多行插入。如：`insert ... values()`

- 批量插入

  <font color=blue>事先不知道要插入的行数</font>，INnoDB在每处理一行的时候，为AUTO_INCREMENT列分配一个新值，通常用于带有子查询的插入或者导入数据。如：`insert ... select ` 或者 `load data`等；

- 混合插入

  这些是”简单插入“语句但是指定部分新行的自动递增值。如`INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d'); `只是执行了部分id值；

##### 锁定模式

会有一个`innodb_autoinc_lock_mode`来对应不同的锁定模式

- `innodb_autoinc_lock_mode = 0`（传统锁定模式）

  所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，保证表中生成的auto_increment为顺序，且<font color=red>在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 限制并发能力。</font>

- `innodb_autoinc_lock_mode = 1`（连续锁定模式）

  "批量插入"模式下，仍然使用AUTO-INC表级锁，并保持到语句结束；

  "简单插入"模式下，则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则和批量插入一样；

  > mysql8.0之前默认模式

- `innodb_autoinc_lock_mode = 2`（交错锁定模式）

  自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），**为任何给定语句插入的行生成的值可能不是连续的。**

  > 只是mysql8.0之后默认值

#### 元数据锁（MDL锁）

MDL是为了保证在读写过程中，表结构不会变化，因此，如下两种情况，都会为表添加MDL锁

- 当对一个表做增删改查操作的时候，加 **MDL读锁；**
- 当要对表做结构变更操作的时候，加 **MDL 写锁**。



### 行级锁

- 记录锁（Record lock）

  记录锁也就是仅仅把一条记录锁上，对周围的数据没有影响。官方的类型名称为： `LOCK_REC_NOT_GAP`

  > 记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 

  触发方式

  ` WHERE id=1 FOR UPDATE`，会对id为1的数据行添加记录锁

- 间隙锁（Gap Lock）

  **gap锁的提出仅仅是为了防止插入幻影记录而提出的，用于通过加锁方式来实现REPEATABLE-READ隔离级别**，保证在间隙段不会插入`幻影记录`，官方类型名称为：`LOCK_GAP`

  触发方式

  - 唯一索引间隙锁
    - 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：`where id = 1 FOR UPDATE` 
    - 对于查找某一范围内的查询语句，会产生间隙锁，如：`WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;`
  - 普通索引
    - 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁

- 临键锁（Next-Key Lock）

  <font color=blue>是记录锁和间隙锁的结合</font> 有时候我们既想 锁住某条记录 ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： `LOCK_ORDINARY` 

  <font color=red> 这是Innodb 默认的锁类型 </font>

- 插入意向锁

  我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 ，但是**InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构**，表名某个事务想在某个间隙插入新纪录，但是现在处于等待状态，InnoDB就把这种类型的锁命名为"插入意向锁" ，官方的类型名称为：`LOCK_INSERT_INTENTION` 。

  **<font color=red>插入意向锁是一种 Gap锁 ，不是意向锁，在insert操作时产生；不会阻止别的事务继续获取该记录上任何类型的锁</font>**

  

### 页级锁

页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。**页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。**



## 对待锁的态度

### 悲观锁

悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）

### 乐观锁

乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是**不采用数据库自身的锁机制，而是通过程序来实现**。

我们可以采用 版本号机制 或者 CAS机制 实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**。

#### 版本号机制

在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 `UPDATE ... SET version=version+1 WHERE version=version`

#### 时间戳机制

时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突



## 加锁方式

#### 隐式锁

<font color=blue>聚簇索引记录</font>来说，有一个 trx_id 隐藏列，该隐藏列记录着最后改动该记录的 事务 id 。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的 trx_id 隐藏列代表的的就是当前事务的 事务id ，如果其他事务此时想对该记录添加 S锁 或者 X锁 时，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个 X 锁 （也就是为当前事务创建一个锁结构， is_waiting 属性是 false ），然后自己进入等待状态（也就是为自己也创建一个锁结构， is_waiting 属性是 true ）

<font color=blue>二级索引记录</font>来说，本身并没有 trx_id 隐藏列，但是在二级索引页面的 Page Header 部分有一个 PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的 事务id ，如果 PAGE_MAX_TRX_ID 属性值小于当前最小的活跃 事务id ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复聚餐索引记录的做法

> 隐式锁逻辑
>
> 1.  Innodb的每条记录中都一个隐含的trx_id字段，这个字段存在于聚簇索引的B+树中。
> 2. 在操作一条记录前，首先根据记录中的trx_id检查该事务是否是活动的事务（未提交或回滚）。如果是活动的事务，首先将 隐式锁 转换为 显式锁(就是为该事务添加一个锁)。 
> 3. 检查是否有锁冲突，如果有冲突，创建锁，并设为waiting状态。如果没有冲突不加锁，跳到。 
> 4. 等待加锁成功，被唤醒，或者超时。
> 5. 写数据，并将自己的trx_id写入trx_id字段

#### 显式锁

通过特定的语句进行加锁，如：

- `select .... in share mode`

- `select .... for update`

## 其他

- 全局锁

全局所对整个数据库加锁，一般用于全表逻辑备份

加锁命令：

`flush tables with read lock `

# 锁升级

每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。<font color=blue>当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级</font> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。

# 锁的内存结构

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220402234322256.png" alt="image-20220402234322256" style="zoom:45%;" />

## 锁所在事务信息

不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个事务的信息，此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比方说事务ID等

## 索引信息

对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针

##  表锁／行锁信息

表锁结构 和 行锁结构 在这个位置的内容是不同的

- 表锁

  记载着是对哪个表加的锁，还有其他的一些信息

- 行锁

  记载了三个重要的信息：

  - Space ID：记录所在表空间。
  - Page Number：记录所在页号。
  - n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits属性代表使用了多少比特位。

## type_mode

这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分

![image-20220402234917774](https://gitee.com/firewolf/allinone/raw/master/images/image-20220402234917774.png)

### 锁模式（lock_mode）：占用四位，可选值

- `LOCK_IS`（十进制的0 ）：表示共享意向锁，IS
- `LOCK_IX`（十进制的1 ）：表示独占意向锁，IX
- `LOCK_S`（十进制的2）：表示共享锁，S
- `LOCK_X`（十进制的3）：表示排它锁，X
- `LOC_AUTO_INC`（十进制的4）：自增锁：AUOT_INC

### 锁类型（lock_type）

占用4位，当前只用到了第5 、6位

- `LOCK_TABLE`（十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。
- `LOCK_REC`（十进制的  32），也就是当第6个比特位置为1时，表示行级锁。

### 行锁的具体类型（ rec_lock_type ）

使用其余的位来表示。只有在 lock_type 的值为`LOCK_REC`时，也就是只有在该锁为行级锁时，才会被细分为更多的类型。

-  `LOCK_ORDINARY`（十进制的  0）：next_key 锁
- `LOCK_GAP`（十进制的512）：第10位是1的时候，表示gap锁
- `LOCK_REC_NOT_GAP`（十进制1024）：也就是第11位是1的时候，表示记录锁
- `LOCK_INSERT_INTENTION`（十进制2048）：也就是第12位是1的时候，表示插入意向锁

- is_waiting属性
  - 基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：
  - 当第9位是1的时候，表示is_waiting为true，也就是说没有获取到锁

## 其他信息

为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。

## 一堆比特位

如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 PADKVU 属性表示的。一个Bit位映射一行记录，1表示这个记录被加锁
