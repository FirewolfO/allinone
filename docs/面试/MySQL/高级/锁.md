[TOC]

# 并发访问数据的情况

## 读-读

不会引起什么问题，所以，不做任何处理

## 写-写

会覆盖别的事务的写操作，出现脏写的问题，所以如果出现写-写的情况，需要让多个事务排队等待，这个排队等待的过程，通过锁来实现。

锁其实就是内存中的一个结构，在执行事务前本来是没有锁结构和行记录进行关联；当记录要被修改的时候，先看看内存中有没有这个锁结构，如果没有，就生成一个，和这个记录以及事务关联上。

锁结构内容：

- 事务信息
- is_waiting：是否处于等待状态

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220402152523392.png" alt="image-20220402152523392" style="zoom:50%;" />

- 不加锁：不需要在内存中生成和记录关联的锁结构，直接执行操作
- 加锁成功：在内存中生成了对应的 锁结构 ，而且锁结构的 is_waiting 属性为 false ，也就是事务可以继续执行操作
- 加锁失败：意思就是在内存中生成了对应的 锁结构 ，不过锁结构的 is_waiting 属性为 true ，也就是事务需要等待，不可以继续执行操作

## 读-写 或 写-读

读-写 或 写-读 ，即一个事务进行读取操作，另一个进行改动操作。这种情况下可能发生 脏读 、 不可重复读 、 幻读 的问题。

<font color=red> MYSQL 在 Repeatable-Read 隔离级别解决了上述读写问题</font>



# 并发问题解决方案

#### 加锁

对读写操作都采用加锁的方式执行

#### 多版本控制（MVCC）

mysql中，普通的SELECT语句在READ COMMITTED和REPEATABLE READ隔离级别下会使用到MVCC读取记录

### 对比

- 采用 MVCC 方式的话， 读-写 操作彼此并不冲突， 性能更高 
- 采用 加锁 方式的话， 读-写 操作彼此需要 排队执行 ，影响性能
- 一般使用mvcc方式来实现



# 锁的分类

## 按操作类型划分

### 读锁（共享锁 / S锁）

针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。

### 写锁（排它锁 / X锁）

当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。

## 按锁粒度划分

### 表级锁（Table Lock）

#### 表级S锁、X锁

一般以下两种情况会用到表级S锁和X锁：

- 在数据库崩溃恢复过程中会用到；
- 在系统变量 autocommit=0，innodb_table_locks = 1 时， 手动 获取InnoDB存储引擎提供的表t 的 S锁 或者 X锁 
  - `LOCK TABLES t READ`：对表t加表级S锁
  - `LOCK TABLES t WRITE `：对表t加表级X锁

#### 意向锁（INTENSION LOCK）

InnoDB 支持多粒度锁 ，并允许行级锁和表级锁 共存，而**意向锁**就是其中的一种 表锁 。

- **意向共享锁**（intention shared lock, IS）：事务有意向对表中的某些行加**共享锁**（S锁）
- **意向排他锁**（intention exclusive lock, IX）：事务有意向对表中的某些行加**排他锁**（X锁）

<font color=red>意向锁是由存储引擎 自己维护的 ，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行 所在数据表的对应意向锁</font>

> 意向锁的并发性
>
> 意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性

#### 自增锁（AUTO_INC锁）

在使用MySQL过程中，我们可以为表的某个列添加 AUTO_INCREMENT 属性

插入的时候，会有不同的插入模式和锁定模式

##### 插入模式

- 简单插入

  <font color=blue>预先确定要插入的行数 </font>，一般在不带嵌套子查询的的单行插入和多行插入。如：`insert ... values()`

- 批量插入

  <font color=blue>事先不知道要插入的行数</font>，INnoDB在每处理一行的时候，为AUTO_INCREMENT列分配一个新值，通常用于带有子查询的插入或者导入数据。如：`insert ... select ` 或者 `load data`等；

- 混合插入

  这些是”简单插入“语句但是指定部分新行的自动递增值。如`INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d'); `只是执行了部分id值；

##### 锁定模式

会有一个`innodb_autoinc_lock_mode`来对应不同的锁定模式

- `innodb_autoinc_lock_mode = 0`（传统锁定模式）

  所有类型的insert语句都会获得一个特殊的表级AUTO-INC锁，保证表中生成的auto_increment为顺序，且<font color=red>在binlog中重放的时候，可以保证master与slave中数据的auto_increment是相同的。因为是表级锁，当在同一时间多个事务中执行insert的时候，对于AUTO-INC锁的争夺会 限制并发能力。</font>

- `innodb_autoinc_lock_mode = 1`（连续锁定模式）

  "批量插入"模式下，仍然使用AUTO-INC表级锁，并保持到语句结束；

  "简单插入"模式下，则通过在 mutex（轻量锁） 的控制下获得所需数量的自动递增值来避免表级AUTO-INC锁， 它只在分配过程的持续时间内保持，而不是直到语句完成。不使用表级AUTO-INC锁，除非AUTO-INC锁由另一个事务保持。如果另一个事务保持AUTO-INC锁，则和批量插入一样；

  > mysql8.0之前默认模式

- `innodb_autoinc_lock_mode = 2`（交错锁定模式）

  自动递增值 保证 在所有并发执行的所有类型的insert语句中是 唯一 且 单调递增 的。但是，由于多个语句可以同时生成数字（即，跨语句交叉编号），**为任何给定语句插入的行生成的值可能不是连续的。**

  > 只是mysql8.0之后默认值

#### 元数据锁（MDL锁）

MDL是为了保证在读写过程中，表结构不会变化，因此，如下两种情况，都会为表添加MDL锁

- 当对一个表做增删改查操作的时候，加 **MDL读锁；**
- 当要对表做结构变更操作的时候，加 **MDL 写锁**。



### 行级锁

- 记录锁（Record lock）

  记录锁也就是仅仅把一条记录锁上，对周围的数据没有影响。官方的类型名称为： `LOCK_REC_NOT_GAP`

  > 记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 

  触发方式

  ` WHERE id=1 FOR UPDATE`，会对id为1的数据行添加记录锁

- 间隙锁（Gap Lock）

  **gap锁的提出仅仅是为了防止插入幻影记录而提出的，用于通过加锁方式来实现REPEATABLE-READ隔离级别**，保证在间隙段不会插入`幻影记录`，官方类型名称为：`LOCK_GAP`

  触发方式

  - 唯一索引间隙锁
    - 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁，如：`where id = 1 FOR UPDATE` 
    - 对于查找某一范围内的查询语句，会产生间隙锁，如：`WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;`
  - 普通索引
    - 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁

- 临键锁（Next-Key Lock）

  <font color=blue>是记录锁和间隙锁的结合</font> 有时候我们既想 锁住某条记录 ，又想 阻止 其他事务在该记录前边的 间隙插入新记录 ，所以InnoDB就提出了一种称之为 Next-Key Locks 的锁，官方的类型名称为： `LOCK_ORDINARY` 

  <font color=red> 这是Innodb 默认的锁类型 </font>

- 插入意向锁

  我们说一个事务在 插入 一条记录时需要判断一下插入位置是不是被别的事务加了 gap锁 ，但是**InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构**，表名某个事务想在某个间隙插入新纪录，但是现在处于等待状态，InnoDB就把这种类型的锁命名为"插入意向锁" ，官方的类型名称为：`LOCK_INSERT_INTENTION` 。

  **<font color=red>插入意向锁是一种 Gap锁 ，不是意向锁，在insert操作时产生；不会阻止别的事务继续获取该记录上任何类型的锁</font>**

  

### 页级锁

页锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。**页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。**



## 对待锁的态度

- 悲观锁
- 乐观锁

## 加锁方式

- 隐式锁
- 显式锁

## 其他

- 全局锁



# 锁升级

每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。<font color=blue>当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级</font> 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。





