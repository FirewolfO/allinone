## 逻辑架构

架构图

![image-20220223183621051](https://gitee.com/firewolf/allinone/raw/master/images/image-20220223183621051.png)

架构分层

- 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；
- SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；
- 存储引擎层：与数据库文件打交道，负责数据的存储和读取。



## SQL执行流程

![image-20220223184733931](https://gitee.com/firewolf/allinone/raw/master/images/image-20220223184733931.png)

流程简述

>  SQL语句→查询缓存→解析器→优化器→执行器

![image-20220224170758656](https://gitee.com/firewolf/allinone/raw/master/images/image-20220224170758656.png)

## 查询缓存

查询缓存判断的条件比较苛刻，需要完全一样，所以命中率较低，功能比较鸡肋，所以在8.0之后，移除了查询缓存

5.x 缓存配置项

```shell
query_cache_type=0 #0 代表关闭，1代表开启
```



## SQL 语句执行顺序

- FROM  <table>
- ON   <join condition> 
- WHERE <where condition>
- GROUP BY <group by list>
- HAVING <having condition>
- SELECT 
- DISTINCT <select list>
- ORDER BY <order by conditon>
- LIMIT <limit number>



## 数据库缓冲池（buffer pool）

InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为 数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访问。

这样做的好处是可以让磁盘活动最小化，从而 减少与磁盘直接进行 I/O 的时间 。

**InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。**

优先对使用频次高的热数据进行加载 。

![image-20220224171414297](https://gitee.com/firewolf/allinone/raw/master/images/image-20220224171414297.png)

#### 缓冲池配置

- 查看缓冲池大小：`show variables like 'innodb_buffer_pool_size'`

- 临时配置缓冲池大小：`set global innodb_buffer_pool_size = 268435456`  单位是B

- 持久化配置缓冲池大小

  ```shell
  [server] 
  innodb_buffer_pool_size = 268435456
  ```

- 配置多个buffer pool 实例

  ```shell
  [server] 
  innodb_buffer_pool_instances = 2
  ```

- 每个buffer pool 大小：`innodb_buffer_pool_size/innodb_buffer_pool_instances`

  

