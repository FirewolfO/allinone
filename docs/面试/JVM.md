[toc]

# 类初始化过程

- 加载
- 连接
  - 验证
  - 准备
  - 解析
- 初始化

# 类加载器

- BootStrap类加载器：加载rt.jar、resource.jar等，只加载特定包下面的类
- ExtClassLoader：加载jar/lib/ext下的包
- AppClassLoader：加载classpath环境变量下的包



# 双亲委派

1. 防止类重复加载
2. 避免核心API被篡改

# 两个类相同的条件

- 类的完整类名必须一样，包括包名；
- 加载它的类加载器必须相同；



# 运行时数据区

## 堆

### 内存划分

- jdk7：新生代 + 老年代 + 永久代（方法区）
- jdk8：新生代 + 老年代 + 元空间
- 新生代：edens、survivor0（from）、survivor1（to）    8:1:1
- 新生代和老年代比例为 1:2
- 

## 方法区

## 虚拟机栈

- 线程私有
- 不存在垃圾回收
- 会出现StackOverflowError

### 栈帧

栈中存储的基本单位，基本一个方法被调用，被封装成一个栈帧，压入到栈中，任何时刻，只有一个是活跃的，包括如下几部分：

- 局部变量表
- 操作数栈
- 动态链接（指向运行时常量池的方法引用）
- 方法返回地址
- 一些附加信息



## 本地方法栈

用于对本地方法的调用，也就是native方法



## 程序计数器

- 也叫PC寄存器，存放下一条指令地址，用于执行引擎读取下一条指令。调用native方法的时候，是undefined
- 没有OutOfMemoryError
- 线程私有



# 垃圾回收

## 垃圾回收分类

- 部分回收
  - Minor GC（年轻代GC）：发生的比较频繁，会引发STW；
  - Major GC（老年代GC）
  - Mixed GC（混合回收）：只有G1垃圾收集器才有这个行为
- Full GC

## GC触发时机

- Minor GC：Eden区满了的时候
- Major GC  / Full GC：Minor GC后空间仍不足，速度比Minor GC 慢10倍，STW时间更长，如果之后空间仍然不足，则OOM；



## TLAB

- 多线程分配内存空间的时候，为了避免并发问题，需要使用加锁等待，从而会影响内存分配的速度；

- JVM为每个线程分配了一块独享的内存，在Eden空间中；

- 提高了内存分配的速度

- 默认情况下，这个空间很小，仅占Eden空间的1%，所以，并不是所有的分配都能在TLAB中完成

  

## 内存分配策略（对象分配过程）

1. 如果开启了TLAB，优先尝试使用TLAB分配空间
2. 优先分配到Eden
3. 大对象直接分配到老年代；
4. 长期存活的对象，会存储到老年代；
5. 动态年龄判断
   - 如果Survivor区中相同年龄的所有对象的大小总和大于Survivor空间的一半，年龄不小于这个这些对象年龄的会直接进入老年代



## 堆是空间分配的唯一选择么？

JIT编译器的发展与逃逸分析技术的成熟，可以通过栈上分配、对象分离、标量替换使得栈上分配变为可能

### 逃逸分析

当一个对象在一个方法中定义之后，如果没有在方法外面被引用，则认为没有发生逃逸，那么可以进行优化；

通过逃逸分析，可以进行如下优化：

- 栈上分配
- 同步省略（不会发生并发的代码，去掉原有的同步逻辑）
- 分离对象和标量替换：可以让一个对象的部分不用存储在连续内存 上；



