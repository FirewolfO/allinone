[toc]

# 类初始化过程

- 加载
- 连接
  - 验证
  - 准备
  - 解析
- 初始化

# 类加载器

- BootStrap类加载器：加载rt.jar、resource.jar等，只加载特定包下面的类
- ExtClassLoader：加载jar/lib/ext下的包
- AppClassLoader：加载classpath环境变量下的包



# 双亲委派

1. 防止类重复加载
2. 避免核心API被篡改

# 两个类相同的条件

- 类的完整类名必须一样，包括包名；
- 加载它的类加载器必须相同；



# 运行时数据区

## 堆

几乎所有的对象都在这里分配，是线程共享的

### 内存划分

- jdk7：新生代 + 老年代 + 永久代（方法区）
- jdk8：新生代 + 老年代 + 元空间
- 新生代：edens、survivor0（from）、survivor1（to）    8:1:1
- 新生代和老年代比例为 1:2
- 

## 方法区

- 多线程共享的内存区域
- JDK7以前，叫做永久代。JDK8以后是元空间（不在JVM内存中，在本地内存中）

### 方法区内容

- 类型信息

  加载的类型（class、interface、enum、annotation）的描述信息

  - 完成类路径
  - 直接父类的完整类路径
  - 类型修饰符（public , abstract, final 等）
  - 直接接口的有序列表

- 运行时常量池

  - 数量值
  - 字符串值
  - 类引用
  - 字段引用
  - 方法引用

- 静态变量

- JIT代码缓存

- 域信息

  就是类中属性字段，会包含描述信息（public，priva，protected，static，final，volaiale，transient等）以及声明顺序

- 方法信息



## 虚拟机栈

- 线程私有
- 不存在垃圾回收
- 会出现StackOverflowError

### 栈帧

栈中存储的基本单位，基本一个方法被调用，被封装成一个栈帧，压入到栈中，任何时刻，只有一个是活跃的，包括如下几部分：

- 局部变量表
- 操作数栈
- 动态链接（指向运行时常量池的方法引用）
- 方法返回地址
- 一些附加信息



## 本地方法栈

用于对本地方法的调用，也就是native方法



## 程序计数器

- 也叫PC寄存器，存放下一条指令地址，用于执行引擎读取下一条指令。调用native方法的时候，是undefined
- 没有OutOfMemoryError
- 线程私有



# 垃圾回收

## 垃圾回收分类

- 部分回收
  - Minor GC（年轻代GC）：发生的比较频繁，会引发STW；
  - Major GC（老年代GC）
  - Mixed GC（混合回收）：只有G1垃圾收集器才有这个行为
- Full GC

## GC触发时机

- Minor GC：Eden区满了的时候
- Major GC  / Full GC：Minor GC后空间仍不足，速度比Minor GC 慢10倍，STW时间更长，如果之后空间仍然不足，则OOM；



## TLAB

- 多线程分配内存空间的时候，为了避免并发问题，需要使用加锁等待，从而会影响内存分配的速度；

- JVM为每个线程分配了一块独享的内存，在Eden空间中；

- 提高了内存分配的速度

- 默认情况下，这个空间很小，仅占Eden空间的1%，所以，并不是所有的分配都能在TLAB中完成

  

## 内存分配策略（对象分配过程）

1. 如果开启了TLAB，优先尝试使用TLAB分配空间
2. 优先分配到Eden
3. 大对象直接分配到老年代；
4. 长期存活的对象，会存储到老年代；
5. 动态年龄判断
   - 如果Survivor区中相同年龄的所有对象的大小总和大于Survivor空间的一半，年龄不小于这个这些对象年龄的会直接进入老年代



## 堆是空间分配的唯一选择么？

JIT编译器的发展与逃逸分析技术的成熟，可以通过栈上分配、对象分离、标量替换使得栈上分配变为可能

### 逃逸分析

当一个对象在一个方法中定义之后，如果没有在方法外面被引用，则认为没有发生逃逸，那么可以进行优化；

通过逃逸分析，可以进行如下优化：

- 栈上分配
- 同步省略（不会发生并发的代码，去掉原有的同步逻辑）
- 分离对象和标量替换：可以让一个对象的部分不用存储在连续内存 上；



# 对象实例化

## 创建对象的方式

1. new 
2. class 的 newInstance
3. 带参数的 newInstance
4. 使用clone
5. 使用反序列化
6. 第三方库 Objenesis



## 创建对象步骤

1. 判断对象对应的类是否加载、连接、初始化，没有则完成这个过程
2. 为对象分配内存
   - 内存规整：指针碰撞
   - 不规整：空闲列表
   - 并发问题处理
     - 每个线程预先分配一块TLAB
     - CAS重试保证操作的原子性
3. 初始化分配到的空间
   - 设置属性默认值，保证对象实例字段在不赋值时可以直接使用
4. 设置对象的对象头信息
5. 执行init方法进行初始化



## 对象内存布局

- 对象头
  - 运行时元数据（mark word）
    - 哈希值
    - GC分代年龄
    - 锁状态标志
    - 线程持有的锁信息
    - 偏向线程ID
    - 偏向时间戳
  - 类型指针：指向类元数据信息，确定对象所属类型
- 实例数据：父类中定义的变量，会出现在子类
- 对齐填充



## 对象访问定位

- 句柄访问：通过句柄池做中转，垃圾回收的时候，不用考虑用户线程

- 直接指针：节省空间、速度更快



# StringTable

## String的基本特性

1. 字符串，使用一堆""引起来表示
2. String声明为final，不可被继承；内容不可变
3. 实现了Serializable接口，表示支持序列化的；实现了Comparable接口，表示String可以比较大小的
4. 在jdk8及以前内部定义了final char[] value用于存储字符串数据，jdk9改为byte[]

## 字符串常量池

1. 是一个固定大小的Hashtable，如果放的String非常多，就会造成hash冲突严重，链表会很长，会影响性能；这个大小可以通过`-XX:StringTableSize `来设置大小，JDK6默认1009，JDK7默认是60013，JDK8可以设置的最小值是1009
2. JDK6及以前，字符串常量池放在永久代；JDK7之后，<font color=red>字符串常量池的位置调整到了Java堆中</font>
   - 都放在堆中，就可以和其他普通对象一下进行内存空间分配；

## intern方法

如果在任意字符上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同，也就是说，会保整这个字符串在内存中只有一份拷贝，并将这个值放在字符串内部池中，从而节省空间，加速字符串操作速度；

("a" + "b" + "c").intern() == "abc" 的结果是true



# 垃圾回收

## 对象是否存活判断（标记阶段）

首先，需要判断对象是否是垃圾，**<font color=red>这是垃圾回收的标记阶段，也是必须"STW"的原因</font>**

判断一个对象是否需要回收，需要经历两次标记过程

1. 如果没有被GC Roots没有引用连，则进行第一次标记；
2. 进行筛选，判断是否要执行finalize方法；
   - 如果对象没有重写finalize方法，则没有必要调用
   - 如果重写了，而且未调用过，则把该对象插入到F-Queue队列中，有一个虚拟机自动创建的Finalizer线程来触发对象的finlize方法；
   - 如果在finalize方法中，与引用连上的任何一个对象建立了联系，那么在第二次标记的时候，会被移除”即将回收“集合

### 引用计数法

无法解决循环引用

### 可达性分析法

#### GC Roots

- 虚拟机栈中引用的对象
  - 如方法中用到的参数、局部变量等
- 本地方法栈中JNI引用的对象
- 方法区中类静态属性引用的对象
  - 如：JAVA类的引用类型静态变量
- 方法区中常量引用的对象
  - 如：字符串常量池里的引用
- 所有被同步锁synchronized持有的对象
- Java虚拟机内部引用
  - 基本数据类型对应的Class对象，一些常驻的异常对象
- 分代回收算法中在被其他分代引用的对象



## finalization机制

对象回收之前，一定会调用这个对象的finalize方法（只会调用一次），这里可以让对象重新复活；



## 垃圾回收算法

### 标记-清除算法

### 标记整理算法

### 复制算法

### 分代收集算法

- 年轻代：复制算法
- 老年代：标记清楚-标记整理混合实现

### 增量收集算法

把堆内存划分成一个一个的小区域，每次回收其中一部分区域，减少stw时间，G1采用



## 安全点 & 安全区

- 安全点：程序不能在任何时刻都进行GC，需要到特定位置才能停下来进行GC，这些位置称为”安全点“，太少会导致GC等待时间太长，如果太频繁会导致运行时的性能问题，一般采用 <font color=red>可以长时间执行的特征</font> 为标准，比如一些执行时间较长的指令来作为Safe Point，如：方法调用、循环跳转、异常跳转等；
- 安全区：针对于程序长时间“不执行”的情况（如：Sleep或者Block状态）。如果一段代码片段中，对象的引用关系不会发生变化，那么这个区域中的任何位置开始GC都是安全的，这种我们称之为安全区；
  - 运行到Safe Region的代码时，会标识已经进入，如果发生GC，会忽略标识为Safe Region状态的线程
  - 离开Safe Region的时候，检查JVM是否已经完成GC，如果完成了继续运行，否则必须等待回收结束，才可以离开Safe Region

> 如何检查是否所有线程都跑到了最近的安全点
>
> - 抢先式中断：首先中断所有线程，如果有线程没有到，则恢复线程，让其跑到安全点
> - 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果这个标志为真，则讲自己进行挂起中断；



## 垃圾收集器

### 串行收集器

- Serial：复制算法、stw
- Serial Old：标记-整理算法、stw

### 并行收集器

- ParNew：复制算法、stw
- Parallel Scavenge：复制算法、stw
- Parallel Old：标记整理、stw

### 并发收集器

- CMS：标记清除算法（初始标记（stw）和并发标记）

- G1：分Region回收，stw时间可控，分代回收

### 各种收集器的搭配

![image-20220418224804744](https://gitee.com/firewolf/allinone/raw/master/images/image-20220418224804744.png)
