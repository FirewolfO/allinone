# 死锁

## 死锁原因

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系



## 避免死锁

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。



# 可重入锁

- RetrantLock 和 Synchronized都是可重入锁可以多次获取到锁的，每次获取锁，加锁的标记数加+1，解锁的时候-1，加锁和解锁是配对的
- 采用AQS来实现锁



# Synchronized 和 CAS区别

- CAS：乐观锁的一种实现方式，是一个轻量级锁，可能有ABA和循环过多开销过大的问题，JDK旧版本只能操作单个变量
- Synchronized：悲观锁，必须先获取锁，然后再操作，通过monitorenter和monitorexit指令完成同步代码块的进入和离开

# Synchronized加在静态方法和普通方法的区别

- 静态方法锁的是当前类的Class对象
- 普通方法锁的是当前实例对象



# 锁升级过程

- 偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
  - 偏向锁撤销：使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点。首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
- 轻量级锁：创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
- 重量级锁：因为自旋会消耗CPU，为了避免无用的自旋，升级为重量级锁



# 项目使用多线程的地方

数据清洗



# 线程池

- 种类
  - newCachedThreadPool创建一个可缓存线程池程
  - newFixedThreadPool 创建一个定长线程池
  - newScheduledThreadPool 创建一个周期性执行任务的线程池
  - newSingleThreadExecutor 创建一个单线程化的线程池
- 核心参数
  - corePoolSize：核心线程数
  - maxPoolSize：最大线程数
  - keepAlivetime：线程空闲时间
  - unit：线程等待时间单位
  - rejectedExecutionHandler：任务拒绝处理器
    - AbortPolicy ：丢弃任务，抛出异常
    - CallerRunsPolicy：执行任务
    - DiscardPolicy：忽略
    - DiscardOldestPolicy：从队列中踢出最先进入队列
  - threadFactory：线程工厂
  - blockingQueue：阻塞队列
- 线程个数设置 
  - 最佳线程数 = Ncpu * Ucpu * (1 + W/C)
    - Ncpu：CPU核数，如 12
    - Ucpu：CPU利用率，如0.9
    - W/C：等待时间/计算时间，如：50（sleep时间） / 50 (循环50_000_000耗时)   = 1



# CountDownLanch 、CycleBarrier、Semaphore





# HashMap 问题



# Volitale底层实现



# IO模型