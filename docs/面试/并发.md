[toc]

# 死锁

## 死锁原因

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系



## 避免死锁

- 避免一个线程同时获取多个锁
- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
- 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。
- 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。



# Java并发机制的底层实现原理

Java中所使用的并发机制依赖于JVM的实现和CPU的指令。

这主要由以下几部分组成：

- volitale
- 锁

# Volitale

## 底层实现

如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，接下来，通过以下两条规则实现volitale的可见性

1. **Lock前缀指令会引起处理器缓存回写到内存**
   - 锁总线（如Intel486和Pentium处理器）：在多处理器环境中，在总线锁定期间，处理器可以独占任何共享内存，开销比较大
   - 锁缓存（大部分处理器）：如果访问的内存区域已经缓存在处理器内部，会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。
2. **一个处理器的缓存回写到内存会导致其他处理器的缓存无效**
   - 通过缓存一致性协议MESI（修改、独占、共享、无效）去维护内部缓存和其他处理器缓存的一致性；
   - 处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致；如果通过嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充



# 可重入锁

- RetrantLock 和 Synchronized都是可重入锁可以多次获取到锁的，每次获取锁，加锁的标记数加+1，解锁的时候-1，加锁和解锁是配对的
- 采用AQS来实现锁



# Synchronized 和 CAS区别

- CAS：乐观锁的一种实现方式，是一个轻量级锁，可能有ABA和循环过多开销过大的问题，JDK旧版本只能操作单个变量
- Synchronized：悲观锁，必须先获取锁，然后再操作，通过monitorenter和monitorexit指令完成同步代码块的进入和离开

# Synchronized加在静态方法和普通方法的区别

- 静态方法锁的是当前类的Class对象
- 普通方法锁的是当前实例对象



# Synchronized底层实现

对象监视器Monitor，通过CAS改变其MarkDown的状态变化来完成锁状态的变化

Monitor是基于C++实现的，由ObjectMonitor实现的，ObjectMonitor中有几个关键属性：

_owner：指向持有ObjectMonitor对象的线程
_WaitSet：存放处于wait状态的线程队列
_EntryList：存放处于等待锁block状态的线程队列
_recursions：锁的重入次数
_count：用来记录该线程获取锁的次数
_cxq：多线程竞争锁进入时的单向链表



# Lock底层实现

AQS：CAS + volitale变量



# 锁升级过程

- 偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。
  - 偏向锁撤销：使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点。首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。
- 轻量级锁：创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。
- 重量级锁：因为自旋会消耗CPU，为了避免无用的自旋，升级为重量级锁



# 项目使用多线程的地方

数据清洗



# 线程池

- 种类
  - newCachedThreadPool创建一个可缓存线程池程
  - newFixedThreadPool 创建一个定长线程池
  - newScheduledThreadPool 创建一个周期性执行任务的线程池
  - newSingleThreadExecutor 创建一个单线程化的线程池
- 核心参数
  - corePoolSize：核心线程数
  - maxPoolSize：最大线程数
  - keepAlivetime：线程空闲时间
  - unit：线程等待时间单位
  - rejectedExecutionHandler：任务拒绝处理器
    - AbortPolicy ：丢弃任务，抛出异常
    - CallerRunsPolicy：执行任务
    - DiscardPolicy：忽略
    - DiscardOldestPolicy：从队列中踢出最先进入队列
  - threadFactory：线程工厂
  - blockingQueue：阻塞队列
- 线程个数设置 
  - 最佳线程数 = Ncpu * Ucpu * (1 + W/C)
    - Ncpu：CPU核数，如 12
    - Ucpu：CPU利用率，如0.9
    - W/C：等待时间/计算时间，如：50（sleep时间） / 50 (循环50_000_000耗时)   = 1



# Concurrent包

整体结构组成

![image-20220407095928969](https://gitee.com/firewolf/allinone/raw/master/images/image-20220407095928969.png)

# CountDownLanch 、CycleBarrier、Semaphore





# HashMap 问题



