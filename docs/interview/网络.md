# TCP/IP模型

下图从左到右分别对应了四层、五层、七层模型

 ![image-20220405124455717](../../../../../Library/Application Support/typora-user-images/image-20220405124455717.png)



# 三次握手、四次挥手过程及TCP状态变化

## 三次握手

1. 第一次握手：建立连接时，客户端发送SYN包（syn=1）到服务器，并进入SYN_SENT状态，等待服务器确认。
2. 第二次握手：服务器收到SYN包，必须确认客户端的SYN包（ack=x+1），同时自己也发送一个SYN包（syn=1），即SYN+ACK包，此时服务器进入SYN_RECV状态。
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

> 至此，TCP连接就建立了，客户端和服务器可以愉快地“玩耍”了。只要通信双方没有一方发出连接释放的请求，连接就将一直保持。如果有一方释放连接，就会发起挥手操作。

## 四次挥手

- 第一次挥手：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文头部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN_WAIT_1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

- 第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务器就进入了CLOSE_WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器方向的连接就被释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接收。这个状态还要持续一段时间，也就是整个CLOSE_WAIT状态持续的时间。

  > 客户端收到服务器的确认请求后，客户端就进入FIN_WAIT_2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接收服务器发送的最后的数据）。

- 第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME_WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2×MSL（最长报文段寿命）的时间，当客户端撤销相应的TCB（Transmit Control Block，传输控制模块）后，才进入CLOSED状态。

> 最后，服务器只要收到了客户端发出的确认，就立即进入CLOSED状态。同样，撤销TCB后，就结束了这次TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

 <img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20220405124121692.png" alt="image-20220405124121692" style="zoom:150%;" />



