[TOC]

# awk简介

awk是一种非常强大的数据处理工具，其本身可以称为一种程序设计语言，因而具有其他程序设计语言所共同拥有的一些特征，例如变量、函数，以及表达式等。通过awk，用户可以编写一些非常实用的文本处理工具。本节将介绍awk的基础知识。

## 基本语法：

```powershell
awk [选项参数] pattern { actions }
```

在上面的语法中，pattern表示匹配模式，actions表示要执行的操作。以上语法表示当某个文本行符合pattern指定的匹配规则时，执行actions所执行的操作。在上面的语法中， pattern和actions都是可选的，但是两者必须保证至少有一个。如果省略匹配模式pattern，则表示对所有的文本行执行actions所表示的操作；如果省略actions，则表示将匹配成功的行输出到屏幕。

注意：actions前面的左大括号需与pattern位于同一行中

## 工作流程

在awk处理数据时，它会反复执行以下4个步骤：

（1）自动从指定的数据文件中读取行文本。

（2）自动更新awk的内置系统变量的值，例如列数变量NF、行数变量NR、行变量$0，以及各个列变量$1、$2等。

（3）依次执行程序中所有的匹配模式及其操作。

（4）当执行完程序中所有的匹配模式及其操作之后，如果数据文件中仍然有末读取的数据行，则返回到第（1）步，重复执行（1）～（4）的操作

<img src="https://gitee.com/firewolf/allinone/raw/master/images/image-20200812225734036.png"  width="400"  height = "400" />



## 执行awk程序的方式

与sed工具相似，用户也可以通过3种方式来执行awk程序，分别是命令行、awk脚本，以及可执行文件。

score.txt：

```txt
zangsan 12
liuxing 34
wangwu 99
lisi 80
tianqi 3
```

1. 通过命令行执行awk程序

   ```powershell
   awk [选项参数] 'program-text' datafile
   ```

   如：

   ```powershell
    awk '{print}' score.txt
   ```

2. 执行awk脚本

   ```po
   awk [选项参数] -f program-file file ..
   ```

   如：

   aw2.sh：

   ```powershell
   {print}
   ```

   执行程序

   ```powershell
   awk -f awk2.sh score.txt 
   ```

3. 可执行脚本文件

   ```powershell
   awk-script file
   ```

   awk的脚本文件，需要执行命令解释器：

   ```
   #!/bin/awk -f
   ```

   不过，具体awk在哪里，建议通过whereis命令查找一下。

   如：

   awk.sh

   ```powershell
   #!/usr/bin/awk -f
   {print}
   ```

   执行awk程序

   ```powershell
    ./awk.sh score.txt 
   ```



## 选项参数

- -F fs or --field-separator fs
  指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。
- -v var=value or --asign var=value
  赋值一个用户定义变量。
- -f scripfile or --file scriptfile
  从脚本文件中读取awk命令。
- -mf nnn and -mr nnn
  对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。
- -W compact or --compat, -W traditional or --traditional
  在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。
- -W copyleft or --copyleft, -W copyright or --copyright
  打印简短的版权信息。
- -W help or --help, -W usage or --usage
  打印全部awk选项和每个选项的简短说明。
- -W lint or --lint
  打印不能向传统unix平台移植的结构的警告。
- -W lint-old or --lint-old
  打印关于不能向传统unix平台移植的结构的警告。
- -W posix
  打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。
- -W re-interval or --re-inerval
  允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。
- -W source program-text or --source program-text
  使用program-text作为源代码，可与-f命令混用。
- -W version or --version
  打印bug报告信息的版本。

# awk的匹配模式

在awk中，匹配模式处于非常重要的地位，它决定着匹配模式后面的操作会影响到哪些文本行。awk中的匹配模式主要包括关系表达式、正则表达式、混合模式，BEGIN模式，以及END模式等。

## 关系表达式

awk提供了许多关系运算符，例如大于＞、小于＜或者等于==等，关于关系运算符的详细使用方法。awk允许用户使用关系表达式作为匹配模式，当某个文本行满足关系表达式时，将会执行相应的操作。

如：找出第二列值大于20的数据

```powershell
 awk '$2 > 20 { print }' score.txt
```

## 正则表达式

awk支持以正则表达式作为匹配模式，与sed一样，用户需要将正则表达式放在两条斜线之间。

```powershell
/regular_expression/
```

如：

```powershell
awk '/liuxing/ {print}' score.txt 
```

## 混合模式

awk不仅支持单个的关系表达式或者正则表达式作为模式，还支持使用逻辑运算符&&、||或者!将多个表达式组合起来作为一个模式。其中，&&表示逻辑与，||表示逻辑或，!表示逻辑非。

如：

```powershell
awk '/liuxing/ && $2>20  {print}' score.txt 
```

## 区间模式

awk还支持一种区间模式，也就是说通过模式可以匹配一段连续的文本行

```powershell
pattern1, pattern2
```

如：

```powershell
awk  '/zangsan/,$2>20 {print}' score.txt 
```

## BEGIN模式

BEGIN模式是一种特殊的内置模式，其成立的时机为awk程序刚开始执行，但是又尚未读取任何数据之前。因此，该模式所对应的操作仅仅被执行一次，当awk读取数据之后， BEGIN模式便不再成立。所以，用户可以将与数据文件无关，而且在整个程序的生命周期中，只需执行一次的代码放在BEGIN模式对应的操作中。

如：

begin.sh

```powershell
BEGIN{
        print "Hello,World!"
}
```

执行：

```powershell
awk -f begin.sh
```

这个程序只是打印了"Hello,World!"

或者直接通过命令形式：

```powershell
 awk 'BEGIN{print "Hello,World!"}'
```



## END模式

END模式是awk的另外一种特殊模式，该模式成立的时机与BEGIN模式恰好相反，它是在awk命令处理完所有的数据，即将退出程序时成立，在此之前，END模式并不成立。无论数据文件中包含多少行数据，在整个程序的生命周期中，该模式所对应的操作只被执行一次。因此，一般情况下，用户可以将许多善后工作放在END模式对应的操作中。

end.sh

```powershell
BEGIN{
        print "start!"
}
{ print }
END{
        print "end"
}

```

执行：

```powershell
 awk -f end.sh score.txt
```



# 变量

与其他程序设计语言一样，awk本身支持变量的相关操作，包括变量的定义和引用，以及参与相关的运算

## 系统内置变量

akw提供了许多非常实用的系统变量，例如字段变量、字段数变量，以及记录数变量等

| 变量        | 描述                                                       |
| :---------- | :--------------------------------------------------------- |
| $n          | 当前记录的第n个字段，字段间由FS分隔                        |
| $0          | 完整的输入记录                                             |
| ARGC        | 命令行参数的数目                                           |
| ARGIND      | 命令行中当前文件的位置(从0开始算)                          |
| ARGV        | 包含命令行参数的数组                                       |
| CONVFMT     | 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组          |
| ERRNO       | 最后一个系统错误的描述                                     |
| FIELDWIDTHS | 字段宽度列表(用空格键分隔)                                 |
| FILENAME    | 当前文件名                                                 |
| FNR         | 各文件分别计数的行号                                       |
| FS          | 字段分隔符(默认是任何空格)                                 |
| IGNORECASE  | 如果为真，则进行忽略大小写的匹配                           |
| NF          | 一条记录的字段的数目                                       |
| NR          | 已经读出的记录数，就是行号，从1开始                        |
| OFMT        | 数字的输出格式(默认值是%.6g)                               |
| OFS         | 输出记录分隔符（输出换行符），输出时用指定的符号代替换行符 |
| ORS         | 输出记录分隔符(默认值是一个换行符)                         |
| RLENGTH     | 由match函数所匹配的字符串的长度                            |
| RS          | 记录分隔符(默认是一个换行符)                               |
| RSTART      | 由match函数所匹配的字符串的第一个位置                      |
| SUBSEP      | 数组下标分隔符(默认值是/034)                               |

awk会在读取数据行之前通过FS及RS确定记录和字段的分隔符，然后进行记录和字段的分隔。每读取一条记录之后，变量$0以及$1、$2等变量都会自动更新。

其中FS和RS，我们可以在BEGIN模式中进行更改。

下面演示部分变量的使用

首先，我把上面的score.txt中的空格全部替换成逗号，保存到score2.txt

```powershell
sed 's/ /,/g' score.txt  >score2.txt
```

然后，我打印这个文件里面的名字，最后打印出文件名

awk-vari.sh

```powershell
BEGIN{
        FS=","
}
{
        print $1 
}
END{
        print "filename is " FILENAME
}  
```

执行：

```po
awk -f awk-vari.sh score2.txt
```

效果如下：

```
zangsan
liuxing
wangwu
lisi
tianqi
filename is score2.txt
```



# 运算符

awk中也支持很多的运算符。

## 算术运算符

| 运　算　符 | 说　明   | 举　例                  |
| ---------- | -------- | ----------------------- |
| +          | 加法运算 | 1+2表示计算1和2的和     |
| -          | 减法运算 | 82-2表示计算82和2的差   |
| *          | 乘法运算 | 2*5表示计算2和5的积     |
| /          | 除法运算 | 6/3表示计算6和2的商     |
| %          | 求模运算 | 5/2表示计算5除以2的余数 |
| ^          | 指数运算 | 2^3表示计算2的3次方     |

## 赋值运算符

| 运　算　符 | 说　明                                                       | 举　例                                                       |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| =          | 赋值运算                                                     | x=5表示将数值5赋给变量x                                      |
| +=         | 复合赋值运算，表示将前后两个数值相加后的和赋给前面的变量     | x+=5表示先将x的值与5相加，然后将和赋给变量x，等价于表达式x=x+5 |
| -=         | 复合赋值运算，表示将前后两个数值相减后的查赋给前面的变量     | x-=5表示先将变量x的值减去5，然后将得到的差赋给变量x，等价于表达式x=x-5 |
| *=         | 复合赋值运算，表示前后两个数值的乘积赋给前面的变量           | x*=5表示先将变量x的值乘以5，然后将得到的乘积赋给变量x        |
| /=         | 复合赋值运算，表示将前后两个数值的商赋给前面的变量           | x/=5表示先将变量x除以5，然后将得到的商赋给变量x              |
| %=         | 复合赋值运算，表示将前面的数值除以后面的数值所得的余数赋给前面的变量 | x%=5表示将变量x与5相除后的余数赋给变量x                      |
| ^=         | 复合运算符，表示将前面的数值的后面数值次方赋给前面的变量     | x^=3表示将变量x的3次方赋给变量x                              |

## 条件运算符

```powershell
expression?value1:value2
```

## 逻辑运算符

| 运　算　符 | 说　明                                                       | 举　例              |
| ---------- | ------------------------------------------------------------ | ------------------- |
| &&         | 逻辑与，当前后两个表达式的值全部为真时，其运算结果才为真，反之则为假 | 1>2&&3>2的值为假    |
| \|\|       | 逻辑或，前后两个表达式只要有一个为真，则其运算结果为真。当两个表达式的值都为假时，其运算结果才为假 | •1>2\|\|3>2的值为真 |
| !          | 逻辑非，当表达式的值为真时，其运算结果为假；当表达式的值为假时，其运算结果为真 | !(1>2)的值为真      |

## 关系运算符

| 运算符 | 说　明       | 举　例                                      |
| ------ | ------------ | ------------------------------------------- |
| >      | 大于         | 5>2的值为真                                 |
| >=     | 大于或者等于 | 8>=8的值为真                                |
| <      | 小于         | 8<12的值为假                                |
| <=     | 小于或者等于 | 4<=7的值为真                                |
| ==     | 等于         | 8==8的值为真                                |
| !=     | 不等于       | 1!=3的值为真                                |
| ～     | 匹配运算符   | $1～/^T/表示匹配第1个字段以字符T开头的记录  |
| !～    | 不匹配运算符 | $1 !～/a/表示匹配第1个字段不含有字符a的记录 |

## 其他运算符

除了前面介绍的运算符之外，awk还支持其他的一些运算符，例如正号+、负号-、自增++，以及自减--等



# 函数

awk提供函数的支持。awk本身提供了许多系统函数，例如字符串函数以及算术函数。另外，用户还可以自定义函数。

## 字符串函数

常用字符串函数如下表：

| **函数**                            | **说明**                                                     |
| :---------------------------------- | :----------------------------------------------------------- |
| gsub( Ere, Repl, [ In ] )           | gsub 是全局替换( global substitution )的缩写。除了正则表达式所有具体值被替代这点，它和 sub 函数完全一样地执行。 |
| sub(regex,sub,string)               | sub 函数执行一次子串替换。它将第一次出现的子串用 regex 替换。第三个参数是可选的，默认为 $0。 |
| substr(str, start, l)               | substr 函数返回 str 字符串中从第 start 个字符开始长度为 l 的子串。如果没有指定 l 的值，返回 str 从第 start 个字符开始的后缀子串。 |
| index( String1, String2 )           | 在由 String1 参数指定的字符串（其中有出现 String2 指定的参数）中，返回位置，从 1 开始编号。如果 String2 参数不在 String1 参数中出现，则返回 0（零）。 |
| length [(String)]                   | 返回 String 参数指定的字符串的长度（字符形式）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 |
| blength [(String)]                  | 返回 String 参数指定的字符串的长度（以字节为单位）。如果未给出 String 参数，则返回整个记录的长度（$0 记录变量）。 |
| substr( String, M, [ N ] )          | 返回具有 N 参数指定的字符数量子串。子串从 String 参数指定的字符串取得，其字符以 M 参数指定的位置开始。M 参数指定为将 String 参数中的第一个字符作为编号 1。如果未指定 N 参数，则子串的长度将是 M 参数指定的位置到 String 参数的末尾 的长度。 |
| match( String, Ere )                | 在 String 参数指定的字符串（Ere 参数指定的扩展正则表达式出现在其中）中返回位置（字符形式），从 1 开始编号，或如果 Ere 参数不出现，则返回 0（零）。RSTART 特殊变量设置为返回值。RLENGTH 特殊变量设置为匹配的字符串的长度，或如果未找到任何匹配，则设置为 -1（负一）。 |
| split( String, A, [Ere] )           | 将 String 参数指定的参数分割为数组元素 A[1], A[2], . . ., A[n]，并返回 n 变量的值。此分隔可以通过 Ere 参数指定的扩展正则表达式进行，或用当前字段分隔符（FS 特殊变量）来进行（如果没有给出 Ere 参数）。除非上下文指明特定的元素还应具有一个数字值，否则 A 数组中的元素用字符串值来创建。 |
| tolower( String )                   | 返回 String 参数指定的字符串，字符串中每个大写字符将更改为小写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |
| toupper( String )                   | 返回 String 参数指定的字符串，字符串中每个小写字符将更改为大写。大写和小写的映射由当前语言环境的 LC_CTYPE 范畴定义。 |
| sprintf(Format, Expr, Expr, . . . ) | 根据 Format 参数指定的 printf 子例程格式字符串来格式化 Expr 参数指定的表达式并返回最后生成的字符串。 |
| strtonum(str)                       | strtonum 将字符串 str 转换为数值。 如果字符串以 0 开始，则将其当作十进制数；如果字符串以 0x 或 0X 开始，则将其当作十六进制数；否则，将其当作浮点数。 |

## 算术函数

| **函数名**      | **说明**                                                     |
| :-------------- | :----------------------------------------------------------- |
| atan2( y, x )   | 返回 y/x 的反正切。                                          |
| cos( x )        | 返回 x 的余弦；x 是弧度。                                    |
| sin( x )        | 返回 x 的正弦；x 是弧度。                                    |
| exp( x )        | 返回 x 幂函数。                                              |
| log( x )        | 返回 x 的自然对数。                                          |
| sqrt( x )       | 返回 x 平方根。                                              |
| int( x )        | 返回 x 的截断至整数的值。                                    |
| rand( )         | 返回任意数字 n，其中 0 <= n < 1。                            |
| srand( [Expr] ) | 将 rand 函数的种子值设置为 Expr 参数的值，或如果省略 Expr 参数则使用某天的时间。返回先前的种子值。 |

## 位操作函数

| 函数              | 描述         |
| ----------------- | ------------ |
| and(num1,num2)    | 位与操作。   |
| compl(num)        | 按位求补。   |
| lshift(num,count) | 左移位操作   |
| rshift(num,count) | 右移位操作   |
| or(num1,num2)     | 按位或操作   |
| xor(num1,num2)    | 按位异或操作 |

## 时间函数

| **函数名**                         | **说明**                                                     | **实例**                                                     |
| :--------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| mktime( YYYY MM DD HH MM SS[ DST]) | 根据指定格式生成时间                                         | mktime("2014 12 14 30 20 10") }                              |
| strftime([format [, timestamp]])   | 格式化时间输出，将时间戳转为时间字符串 具体格式，见下表.     | `$ awk 'BEGIN {    print strftime("Time = %m/%d/%Y %H:%M:%S", systime()) }'`输出结果为：`Time = 12/14/2014 22:08:42` |
| systime()                          | 得到时间戳,返回从1970年1月1日开始到当前时间(不计闰年)的整秒数 | `awk 'BEGIN{now=systime();print now}'`输出结果为：`1343210982` |

strftime日期和时间格式说明符：

| 序号 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| %a   | 星期缩写(Mon-Sun)。                                          |
| %A   | 星期全称（Monday-Sunday）。                                  |
| %b   | 月份缩写（Jan）。                                            |
| %B   | 月份全称（January）。                                        |
| %c   | 本地日期与时间。                                             |
| %C   | 年份中的世纪部分，其值为年份整除100。                        |
| %d   | 十进制日期(01-31)                                            |
| %D   | 等价于 %m/%d/%y.                                             |
| %e   | 日期，如果只有一位数字则用空格补齐                           |
| %F   | 等价于 %Y-%m-%d，这也是 ISO 8601 标准日期格式。              |
| %g   | ISO8610 标准周所在的年份模除 100（00-99)。比如，1993 年 1 月 1 日属于 1992 年的第 53 周。所以，虽然它是 1993 年第 1 天，但是其　ISO8601 标准周所在年份却是 1992。同样，尽管 1973 年 12 月 31 日属于 1973 年但是它却属于 1994 年的第一周。所以 1973 年 12 月 31 日的 ISO8610　标准周所在的年是 1974 而不是 1973。 |
| %G   | ISO 标准周所在年份的全称。                                   |
| %h   | 等价于 %b.                                                   |
| %H   | 用十进制表示的 24 小时格式的小时(00-23)                      |
| %I   | 用十进制表示的 12 小时格式的小时（00-12）                    |
| %j   | 一年中的第几天（001-366）                                    |
| %m   | 月份（01-12）                                                |
| %M   | 分钟数（00-59)                                               |
| %n   | 换行符 (ASCII LF)                                            |
| %p   | 十二进制表示法（AM/PM）                                      |
| %r   | 十二进制表示法的时间（等价于 %I:%M:%S %p）。                 |
| %R   | 等价于 %H:%M。                                               |
| %S   | 时间的秒数值（00-60）                                        |
| %t   | 制表符 (tab)                                                 |
| %T   | 等价于 %H:%M:%S。                                            |
| %u   | 以数字表示的星期(1-7),1 表示星期一。                         |
| %U   | 一年中的第几个星期（第一个星期天作为第一周的开始），00-53    |
| %V   | 一年中的第几个星期（第一个星期一作为第一周的开始），01-53。  |
| %w   | 以数字表示的星期（0-6），0表示星期日 。                      |
| %W   | 十进制表示的一年中的第几个星期（第一个星期一作为第一周的开始），00-53。 |
| %x   | 本地日期表示                                                 |
| %X   | 本地时间表示                                                 |
| %y   | 年份模除 100。                                               |
| %Y   | 十进制表示的完整年份。                                       |
| %z   | 时区，表示格式为+HHMM（例如，格式要求生成的 RFC 822或者 RFC 1036 时间头） |
| %Z   | 时区名称或缩写，如果时区待定则无输出。                       |

## 其他函数

| **函数名** | **说明**                                                     | **实例**                                                     |
| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| delete     | 用于从数组中删除元素                                         | `delete arr[0]`                                              |
| exit       | 终止脚本执行，它可以接受可选的参数 expr 传递 AWK 返回状态。  | `exit 10`                                                    |
| flush      | 刷新打开文件或管道的缓冲区                                   |                                                              |
| getline    | 读入下一行                                                   | `$ awk '{getline; print $0}' marks.txt `，AWK 从文件 marks.txt 中读入一行存储到变量 0 中 |
| next       | 停止处理当前记录，并且进入到下一条记录的处理过程。           |                                                              |
| nextfile   | 停止处理当前文件，从下一个文件第一个记录开始处理。           |                                                              |
| return     | 从用户自定义的函数中返回值。请注意，如果没有指定返回值，那么的返回值是未定义的。 |                                                              |
| system     | 执行特定的命令然后返回其退出状态。返回值为 0 表示命令执行成功；非 0 表示命令执行失败。 |                                                              |

## 自定义函数

语法：

```powershell
function function_name(argument1, argument2, ...)
{
    function body
}
```

示例：

```powershell
function find_min(num1, num2)
{
         if (num1 < num2)
                return num1
         return num2
}

BEGIN{
        result=find_min(10,20)
        print "the min num in (10,20) is " result
}

```

# 数组

awk数组的命名规则与变量名基本相同，也是由字母、数字和下划线组成。另外，awk的数组名也是区分大小写的，例如array和Array是不同的数组名，初学者务必注意这一点。awk数组的下标从1开始计算，即数组的第1个元素的下标为1，第2个元素的下标为2，依此类推。另外，awk也支持关联数组，这与Shell是相同的。所谓关联数组，是指以字符串作为下标的数组。

## 数组定义、赋值

数组元素赋值的语法如下：

```
array[n]=value
```

引用元素：

```
array[n]
```

## 遍历数组

可以通过length()函数来获取数组的长度

```powershell
BEGIN{
        arr[1]=12
        arr[2]="hello"
        arr[4]="world"
        print "array length = "length(arr)
        for(i=1;i<=length(arr);i++)
        {
                print arr[i]
        }
}
```

或者：

```powershell
BEGIN{
        arr[1]=12
        arr[2]="hello"
        arr[4]="world"
        print "array length = "length(arr)
        for(n in arr)
        {
                print arr[n]
        }
}

```



# 流程控制

## 条件判断if

if判断有如下几种语法：

```powershell
if (expression) { statement1 statement2 } else { statement3 statement4 }
```

```powershell
if (expression) statement1 else statement2
```

```powershell
if (expression) { statement1 statement2 }
```



## 循环

awk中有如下几种循环：

### while循环

```powershell
while (expression) { statement1 statement2 ... }
```

### do... while循环

```powershell
do { statement1 statement2 ... }while (expression)
```

### for循环

```powershell
for(expression1; expression2; expression3) { statement1 statement2 ... }
```

### break跳出循环

和java一样，break中断整个循环体；

### continue跳过语句

和java一样，continue跳过本次循环后面的语句



## next语句

next语句的功能与continue语句非常相似，但是next语句并不是用在循环结构中，而是用在整个akw程序中。当awk执行程序时，如果遇到next语句，则该语句后面的所有的程序语句都被忽略，包括其他的模式，以及对应的操作。



## exit语句

exit语句的功能是终止awk程序的执行。该语句的使用方法与其他语句基本相同



# 格式化输出

## 基本print语句

```powershell
print string1,string2,...
```

## 格式化输出printf语句

```powershell
printf(format, [arguments])
```

其中圆括号是可选的，第1个参数format是一个用来描述输出格式的字符串，通常以引号括起来的字符串常量的形式提供。arguments为一个参数列表，表示用来显示的数据，可以是变量名等，多个参数之间用逗号隔开。参数列表的项是有顺序的，与前面的格式化字符串中的格式说明相对应。

格式化字符串如下：

```powershell
%format
```

常用的格式化描述符如下：

| 描　述　符 | 说　明                        |
| ---------- | ----------------------------- |
| %c         | ASCII字符                     |
| %d         | 十进制有符号整数              |
| %u         | 十进制无符号整数              |
| %f         | 浮点数                        |
| %e         | 指数形式的浮点格式            |
| %s         | 字符串                        |
| %0         | 无符号以八进制表示的整数      |
| %x         | %X 无符号以十六进制表示的整数 |

说明：

(1). 可以在"%"和字母之间插进数字表示最大场宽。 
例如: %3d 表示输出3位整型数, 不够3位右对齐。 
%9.2f 表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,小数点占一位, 不够9位右对齐。 
%8s 表示输出8个字符的字符串, 不够8个字符右对齐。 
如果字符串的长度、或整型数位数超过说明的场宽, 将按其实际长度输出.但对浮点数, 若整数部分位数超过了说明的整数位宽度, 将按实际整数位输出;若小数部分位数超过了说明的小数位宽度, 则按说明的宽度以四舍五入输出.
另外, 若想在输出值前加一些0, 就应在场宽项前加个0。 
例如: %04d 表示在输出一个小于4位的数值时, 将在前面补0使其总宽度为4位。 
如果用浮点数表示字符或整型量的输出格式, 小数点后的数字代表最大宽度,小数点前的数字代表最小宽度。 
例如: %6.9s 表示显示一个长度不小于6且不大于9的字符串。若大于9, 则第9个字符以后的内容将被删除。

(2). 可以在"%"和字母之间加小写字母l, 表示输出的是长型数。 
例如: %ld 表示输出long整数 
%lf 表示输出double浮点数 

(3). **可以控制输出左对齐或右对齐, 即在"%"和字母之间加入一个"-" 号可说明输出为左对齐, 否则为右对齐**。 
例如: %-7d 表示输出7位整数左对齐 
%-10s 表示输出10个字符左对齐

如：

```powershell
BEGIN{
        printf("3+4=%d\n",3+4)
}
```

## 使用sprintf()函数生成格式化字符串

sprintf()函数的功能与printf()函数的功能大致相同，但是该函数只是以字符串的形式返回格式化结果，并不输出到标准输出设备。用户可以将格式化的结果进行其他处理或者使用print()和printf()函数输出到标准输出。

如：

```powershell
BEGIN{
        FS=","
        i=1
}
{
        scores[i++]=$2
}
END{
        sum=0
        for(n in scores)
        {
                print scores[n]
                sum+=scores[n]
        }
        avg=sum/length(scores)
        result=sprintf("Total student is %d, total score is %d, avg scores is: %.2f ",NR,sum,avg)
        print result
}
```



# awk程序与shell的交互

awk提供了与Shell命令交互的能力，从而可以使用户在awk程序中使用系统资源。awk主要通过两种机制来实现这种交互功能，分别为管道和sytem函数。本节将对这两种交互机制进行详细介绍。

## 通过管道实现交互

用户可以很容易地在awk程序中使用操作系统资源，包括在程序中调用Shell命令处理程序中的数据；或者在awk程序中获取Shell命令的执行结果。awk提供了管道来实现这种数据的双向交互。

如：

```powershell
BEGIN{
        while("who" | getline)
                n++;
        printf "There is %d users online ! \n", n
}
```

## 通过system函数实现交互

```powershell
system(command)
```

其中参数command表示要执行的Shell命令。与管道相比，system函数有许多据局限，例如不能在awk程序中直接获取Shell命令的执行结果，另外，也不能直接将awk程序中的数据传递给Shell命令来处理。要实现这种数据传递，必须借助其他的手段。

```powershell
BEGIN{
        system("who > tmp.txt")
        while(getline <"tmp.txt" >0)
        {
                n+=1
        }
        printf "There is %d users online !\n",n
}
```

在上面的代码中，使用system函数执行who命令，由于system不支持数据的传递，所以需要借助一个临时文件作为数据传递的桥梁。即将who命令的执行结果重定向到名称为tmp.txt的文件中。然后使用getline函数从数据文件中读取数据，再计算结果。