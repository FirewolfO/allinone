[toc]

# 基本规则

- 函数外的每个语句都必须以关键字开始（`var`, `func` 等等）

# 包

- 每个go程序都是有包构成的

- 程序以main包的main函数作为入口

```go
// 指定包名，不要求必须和文件路径一样
package main

// 引入
imprt (
	"fmt"
	"math/rand"
)
//等价于
/**
import "fmt"
import "math/rand"
*/

func main() {
    // 使用包中的方法
	fmt.Println("My favorite number is", rand.Intn(10))
}


```

# 导出名

- 在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，`Pizza` 就是个已导出名，`Pi` 也同样，它导出自 `math` 包。小写字母开头的是没有导出的

- 在导入一个包时，只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。

```go
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.Pi) // 使用导出的名
}

```



# 函数

## 定义方式

### 方式1：常用方式

```go
/**
    func 函数名 ( 参数1 类型1 , 参数2 类型2 ) 返回类型 {
         函数体内容  
         返回值
    }
*/ 
func add(x int, y int) int {
	return x + y
}
```

### 方式二：省略类型

当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略

```go
/**
    func 函数名(参数1,参数2.... 参数类型) 返回类型{
        函数体
        返回值
    }
*/
func add2(x, y int) int {
	return x + y
}
```

### 方式三：返回多值

函数可以返回任意数量的返回值

```go
/** 
   func 函数名(参数列表) (返回类型1，返回类型2){
       方法体
       返回值
   }
*/

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
```
```

### 方式四：命名返回值

- Go 的返回值可被命名，<font color=red>它们会被视作定义在函数顶部的变量。</font>

- 返回值的名称应当具有一定的意义，它可以作为文档使用。

- 没有参数的 `return` 语句返回已命名的返回值。也就是 `直接` 返回。

```go
/**
    func 函数名( 参数列表 ) (返回值名1 类型1, 返回值名2 类型2 ) {
       ...
       return //不能少
    }
*/
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
```



# 变量

## 定义

`var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后

```go
var 变量1，变量2 ... 类型   // 类型不一定都需要写

var english, math int 
var name string
var age bool
```

## 变量初始化

- 变量声明可以包含初始值，每个变量对应一个。

- 如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。

- 可以声明在函数中或者函数外

```go
var name="zhangsan" // 单个变量初始化
var i, j int = 1,2  // 多个变量初始化，声明类型
var c, python, java = true, false, "no!"  //多个变量初始化，省略类型
```

## 短变量声明

在函数中，简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明

```go
k := 3
```





# 数据类型

## 基本数据类型

- bool

- string

- int  int8  int16  int32  int64

- uint uint8 uint16 uint32 uint64 uintptr

- byte // uint8 的别名

- rune // int32 的别名，表示一个 Unicode 码点

- float32 float64

- complex64 complex128

说明

- 同导入语句一样，变量声明也可以“分组”成一个语法块。
  
  ```go
  var (
  	ToBe   bool       = false
  	MaxInt uint64     = 1<<64 - 1
  	z      complex128 = cmplx.Sqrt(-5 + 12i)
  )
  ```

- `int`, `uint` 和 `uintptr` 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 `int` 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。

## 零值

- 数值类型为 `0`，
- 布尔类型为 `false`，
- 字符串为 `""`（空字符串）。

## 类型转换

表达式 `T(v)` 将值 `v` 转换为类型 `T`。

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
// 短语形式
k := float64(i)
m := uint(k)
fmt.Println(i,f,u,m,k)
```



# 常量

- 常量的声明与变量类似，只不过是使用 `const` 关键字。
- 常量可以是字符、字符串、布尔值或数值。
- 常量不能用 `:=` 语法声明。



# 循环：for

- Go 只有一种循环结构：`for` 循环
- 基本的 `for` 循环由三部分组成，它们用分号隔开：
  - 初始化语句：在第一次迭代前执行（常为一句短变量声明，该变量声明仅在 `for` 语句的作用域中可见）
  - 条件表达式：在每次迭代前求值
  - 后置语句：在每次迭代的结尾执行
- <font color=red>**注意**：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 `{ }` 则是必须的</font>
- 初始化语句和后置语句是可选的

### 基本for循环

三个部分全部具备，如：

```go
for i := 0; i<10; i++ {
    fmt.Printf("i=%d\n", i)
}
```

## 省略初始化

```go
for ; j < 5; j++{
    fmt.Printf("j=%d\n", j)
}
```

## "while"

在go中，没有while关键字，使用for来代替，此时，我们会省略掉

```go
x := 1
for x < 10 {
	fmt.Printf("x=%d\n",x)
    x++
}
```

## 无限循环

```go
for{
    
}
```



# 条件：if - else

- Go 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。
- 没有java中的if ...  else if ... else结构
- <font color=red>在if 或者 else后面的条件中，可以在条件表达式前执行一个简单的语句</font>

```go
func sexJudge(sex int) string{
	if v := 100 ; sex == 1 {
		fmt.Println(v)
		return "男"
	} else {
		fmt.Println(v+10)
		return "女"
	}
}
```



# 条件：switch - case - default

- 整体结构和java中的结构类似
  - 可以省略default
- Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束，否则分支会自动终止。
- Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。

## 基本结构

```go
func convertNumToChinese(num int) string{
	switch num {
	case 10:
		return "十"
	case 100:
		return "百"
	case 1000:
		return "千"
	default:
		return "其他"
	}
}
```

## 无条件switch（可以实现if ... else if ....else）

没有条件的 switch 同 `switch true` 一样。

```java
func converAge(age int) string{
	switch{
	case age >60:
		return "老人"
	case age > 20:
		return "年轻人"
	default:
		return "孩子"
	}
}
```



# defer

- defer 语句会将函数推迟到外层函数返回之后执行
- 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。

```go
func stack(num int){
	for i:=0; i< num; i++{
		defer fmt.Printf("i=%d", i)
	}
}
```

