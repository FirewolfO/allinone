## 简单工厂

```java
public class ProductFactory{
    public Product createProduct(String arg){
        if("A".equals(arg)){
            return new ProductA();
        }else if("B".equals(arg)){
            return new ProductB();
        }
        ....
    }
}
```

```java
public class Product{
    
    Product createProduct(String arg){
        if("A".equals(arg)){
            return new ProductA();
        }else if("B".equals(arg)){
            return new ProductB();
        }
        ....
    }
}
```

```java
public class Client{
    public static void main(String[] args){
        ProductFactory factory = new ProductFactory();
        Product product = factory.createProduct("A");
        ....
    }
}
```



## 工厂方法

```java
public FileLoggerFactory implements LoggerFactory{
    public Logger createLogger(){
        return new FileLogger();
    }
}
```

```java
public Client{
    public static void main(String[] args){
        LoggerFactory factory = new FileLoggerFactory();
        Logger logger = factory.createLogger();
        logger.writeLog();
    }
}
```

## 抽象工厂

```java
public class Client{
  public static void main(String[] args){
    // 下面这个其实可以通过配置文件的方式获取到，
    //从而让Client和SummerSkinFactory等具体工厂解耦
    SkinFactory skinFactory = new SummerSkinFactory();
    Button button = skinFactory.createButton();
    button.displayButton();
    TextField textField = new TextField();
    textField.displayTextField();  
    ....
  }
}
```

```java
public class SummerSkinFactory implements SkinFactory{
  public Button createButton(){
    return new SummerButton();
  }
  public TextField createTextField(){
    return new SummerTextField();
  }
  public ComboBox createComboBox(){
    return new SummerComboBox();
  }
}
```

## 单例模式

- 饿汉式

```java
public class Singleton{
    private static Singleton instance = new Singleton();
    private Singleton(){};
    public static Singleton getInstance(){
        return instance;
    }
}
```



- 饿汉式变种（静态代码块）

```java
public class Singleton{
    private static Singleton instance = null;
    static{
        instance = new Singleton();
    }
    private Singleton(){};
    public static Singleton getInstance(){
        return instance;
    }
}
```



- 懒汉式（线程不安全）

```java
public class Singleton{
    private static Singleton instance = null;
  	private Singleton(){}
  	public static Singleton getInstance(){
    	if(instance == null){
      		instance = new Singleton();
    	}
    	return instance;
  	}
}
```

- 懒汉式（线程安全，效率低）

```java
public class Singleton{
    private static Singleton instance = null;
  	private Singleton(){}
  	public static synchronized Singleton getInstance(){
    	if(instance == null){
      		instance = new Singleton();
    	}
    	return instance;
  	}
}
```

- 双重校验锁

```java
public class Singleton{
    private static Singleton instance = null;
  	private Singleton(){}
  	public static Singleton getInstance(){
    	if(instance == null){
            synchronized(Singleton.class){
                // 需要再次判断是存在，原因见下面：
                if(instance == null){ 
                    instance = new Singleton();
                }
            }
    	}
    	return instance;
  	}
}
```

- 静态内部类实现

```java
public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();   
    }
    private Singleton (){}  
    public static final Singleton getInstance() {  
   		return SingletonHolder.INSTANCE;  
    }  
}  
```

- 枚举实现

```java
public enum Singleton {
    INSTANCE;
    public void doSomething() {
        System.out.println("doSomething");
    }
}
```







## 面试题

- 怎么样在普通的类里面访问Spring容器中的Bean；
- 设计模式中的原型模式，写一个浅克隆和深度克隆的代码；
- 写一个单例模式
- 怎么自定义starter
- mysql的索引原理
- Spring循环依赖怎么发现和解决的；
- Spring对事物的控制
- 分布式事务怎么实现的
- Docker保存镜像到本地命令；
- synchronize关键字底层原理 







- 怎么样在普通的类里面访问Spring容器中的Bean；
- 设计模式中的原型模式，写一个浅克隆和深度克隆的代码；
- 写一个单例模式
- 怎么自定义starter
- mysql的索引原理
- Spring循环依赖怎么发现和解决的；  没听说过
- Spring对事物的控制
- 分布式事务怎么实现的
- Docker保存镜像到本地命令；方便



1. 设计模式

回到常用的有单例，策略，适配器

2. ConcurrentHashMap底层实现  
3. synchronized关键字底层实现  
4. redis数据类型    redis怎么实现分布式锁  
5. Spring循环依赖发现及解决   
6. spring事务的传播行为
7. dubbo架构  
8. zookeeper节点类型  
9. Mybatis 批量插入   
10. ThreadLocal
11. nginx配置转发





docker run -it -e "JAVA_OPTS=-Drocketmq.namesrv.addr=rmqnamesrv:19876 -Dcom.rocketmq.sendMessageWithVIPChannel=false" -p 8001:8080 -t styletang/rocketmq-console-ng